<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA开发规范-阿里规约</title>
    <url>/essay/standard/</url>
    <content><![CDATA[<p>原文地址: <a href="http://www.azhangzhifeng.cn/" target="_blank" rel="noopener">zhangzhifeng的主页</a></p>
<h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h3><p>1.所有编程相关命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例： _name </span></span><br><span class="line">         __name </span><br><span class="line">         $Object</span><br><span class="line">         name_ </span><br><span class="line">         name$</span><br><span class="line">         Object$</span><br></pre></td></tr></table></figure>

<p>2.所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反例 </span><br><span class="line">    DaZhePromotion [打折] getPingfenByName() [评分] <span class="keyword">int</span> 变量 = <span class="number">3</span>;</span><br><span class="line">正例</span><br><span class="line">    ali/alibaba/taobao/cainiao/aliyun/youku/hangzhou等国际通用的名称，可视为英文。</span><br></pre></td></tr></table></figure>

<p>3.类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / DTO / VO / DAO等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">    macroPolo / UserDo/XMLService / TCPUDPDeal / TAPromotion</span><br><span class="line">正例：</span><br><span class="line">    MarcoPolo / UserDO / XmlService /TcpUdpDeal / TaPromotion</span><br></pre></td></tr></table></figure>

<p>4.方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">    localValue / getHttpMessage() /inputUserId</span><br></pre></td></tr></table></figure>

<p>5.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正例： MAX_STOCK_COUNT </span><br><span class="line">反例： MAX_COUNT</span><br></pre></td></tr></table></figure>

<p>6.抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。<br>7.中括号是数组类型的一部分，数组定义如下：String[] args; 反例：请勿使用Stringargs[]的方式来定义<br>8.POJO类中的任何布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：定义为基本数据类型boolean isSuccess；的属性，它的方法也是isSuccess()，</span><br><span class="line">RPC框架在反向解析的时候，“以为”对应的属性名称是success，导致属性获取不到，进而抛出异常。</span><br></pre></td></tr></table></figure>

<p>9.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br><em>正例： 应用工具类包名为com.oceandatum.mpp.util、类名为MessageUtils（此规则参考spring 的框架结构)</em></p>
<p>10.杜绝完全不规范的缩写，避免望文不知义。<br><em>反例：&lt;某业务代码&gt;AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性</em></p>
<p>11.如果使用到了设计模式，建议在类名中体现出具体模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFactory</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginProxy</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceObserver</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>将设计模式体现在名字中，有利于阅读者快速理解架构设计思想</em><br>12.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正例：接口方法签名：<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">     接口基础常量表示：String COMPANY =<span class="string">"oceandatum"</span>;</span><br><span class="line">反例：接口方法定义：<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</em><br>13.接口和实现类的命名有两套规则：</p>
<p>1) 对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正例: CacheServiceImpl实现CacheService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。<br><em>正例：AbstractTranslator实现 Translatable。</em></p>
<p>14.枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。(枚举其实就是特殊的常量类，且构造方法被默认强制是私有。)<br><em>正例：枚举名字：DealStatusEnum；成员名称：SUCCESS / UNKOWN_REASON。</em></p>
<p>15.各层命名规约：</p>
<ul>
<li>Service/DAO/Mapper层方法命名规约<br>  1） 获取单个对象的方法用get做前缀。<br>  2） 获取多个对象的方法用list做前缀。<br>  3） 获取统计值的方法用count做前缀。<br>  4） 插入的方法用save做前缀。<br>  5） 删除的方法用remove做前缀。<br>  6） 修改的方法用update做前缀。</li>
<li>领域模型命名规约<br> 1） 数据对象：xxxDO，xxx即为数据表名。<br> 2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。<br> 3） 展示对象：xxxVO，xxx一般为网页名称。<br> 4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</li>
</ul>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><p>1.不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">String key=<span class="string">"Id#taobao_"</span>+tradeId；</span><br></pre></td></tr></table></figure>

<p>2.long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1 混淆，造成误解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">Long a = <span class="number">2l</span>;<span class="comment">// 写的是数字的21，还是Long型的2?</span></span><br></pre></td></tr></table></figure>

<p>3.【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts下；系统配置相关的常量放在类：ConfigConsts下。</p>
<ul>
<li>大而全的常量类，非得ctrl+f才定位到修改的常量，不利于理解，也不利于维护。</li>
</ul>
<p>4.【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p>
<ul>
<li>跨应用共享常量：放置在二方库中，通常是client.jar中的const目录下。</li>
<li>应用内共享常量：放置在一方库的modules中的const目录下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> 类A中：<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES =<span class="string">"yes"</span>; </span><br><span class="line"> 类B中：<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES =<span class="string">"y"</span>;</span><br><span class="line">       A.YES.equals(B.YES);<span class="comment">//预期是true，但实际返回为false，导致产生线上问题。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子工程内部共享常量：即在当前子工程的const目录下。</li>
<li>包内共享常量：即在当前包下单独的const目录下。</li>
<li>类内共享常量：直接在类内部private static final定义。</li>
</ul>
<p>5.【推荐】如果变量值仅在一个范围内变化用Enum类。如果还带有名称之外的延伸属性，必须使用Enum类，下面正例中的数字就是延伸信息，表示星期几。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*正例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Enum Week&#123;</span><br><span class="line">    MONDAY(<span class="number">1</span>), </span><br><span class="line">    TUESDAY(<span class="number">2</span>),</span><br><span class="line">    WEDNESDAY(<span class="number">3</span>),</span><br><span class="line">    THURSDAY(<span class="number">4</span>),</span><br><span class="line">    FRIDAY(<span class="number">5</span>),</span><br><span class="line">    SATURDAY(<span class="number">6</span>),</span><br><span class="line">    SUNDAY(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h3><p>1.大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：</p>
<ul>
<li>左大括号前不换行。</li>
<li>左大括号后换行。</li>
<li>右大括号前换行。  </li>
<li>右大括号后还有else等代码则不换行；表示终止右大括号后必须换行。</li>
</ul>
<p>2.左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格。详见第5条下方正例提示。<br>3.if/for/while/switch/do等保留字与左右括号之间都必须加空格。<br>4.任何运算符左右必须加一个空格。<br>    <em>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</em><br>5.代码块缩进4个空格，如果使用tab缩进，请设置成1个tab为4个空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正例：（涉及1-5点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringargs[])</span></span>&#123;     </span><br><span class="line">    <span class="comment">// 缩进4个空格     </span></span><br><span class="line">    String say=<span class="string">"hello"</span>;     </span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格     </span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// 关键词if与括号之间必须有一个空格，括号内f与左括号，1与右括号不需要空格     </span></span><br><span class="line">    <span class="keyword">if</span>(flag== <span class="number">0</span>) &#123;         </span><br><span class="line">        System.out.println(say);     </span><br><span class="line">    &#125;              </span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行；左大括号后换行     </span></span><br><span class="line">    <span class="keyword">if</span> (flag ==<span class="number">1</span>)&#123;         </span><br><span class="line">        System.out.println(<span class="string">"world"</span>);     </span><br><span class="line">    <span class="comment">// 右大括号前换行，右大括号后有else，不用换行     </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;           </span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);     </span><br><span class="line">    <span class="comment">// 右大括号做为结束，必须换行      </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.单行字符数限制不超过120个，超出需要换行，换行时，遵循如下原则：  </p>
<p>1) 换行时相对上一行缩进4个空格。<br>2）运算符与下文一起换行。<br>3）方法调用的点符号与下文一起换行。<br>4）在多个参数超长，逗号后进行换行。<br>5）在括号前不要换行，见反例。正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例子</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"><span class="comment">//超过120个字符的情况下，换行缩进4个空格，并且方法前的点符号一起换行  </span></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)…    </span><br><span class="line">.append(<span class="string">"huang"</span>); </span><br><span class="line">反例：</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"><span class="comment">//超过120个字符的情况下，不要在括号前换行 </span></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)…append</span><br><span class="line">(<span class="string">"huang"</span>);  </span><br><span class="line"><span class="comment">//参数很多的方法调用也超过120个字符，逗号后才是换行处 </span></span><br><span class="line">method(args1,args2,args3, ...  </span><br><span class="line">,argsX);</span><br></pre></td></tr></table></figure>
<p>7.方法参数在定义和传入时，多个参数逗号后边必须加空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例 下例中实参的"a",后边必须要有一个空格。</span></span><br><span class="line">method(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>

<p>8.没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">long</span> b = <span class="number">4L</span>; </span><br><span class="line"><span class="keyword">float</span> c = <span class="number">5F</span>; </span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure>
<p><strong><em>说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。</em></strong><br>9.方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行(没有必要插入多行空格进行隔开)</p>
<h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><p>1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。<br>2.所有的覆写方法，必须加@Override注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">getObject()与get0bject()的问题。</span><br><span class="line">一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。</span><br><span class="line">另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</span><br></pre></td></tr></table></figure>

<p>3.相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。<br><strong><em>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUsers</span><span class="params">(Stringtype,Integer... ids)</span></span>;</span><br></pre></td></tr></table></figure>
<p>4.对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。<br>5.不能使用过时的类或方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.net.URLDecoder 中的方法decode(StringencodeStr) 这个方法已经过时，</span><br><span class="line">应该使用双参数decode(String source, Stringencode)。接口提供方既然明确是过时接口，</span><br><span class="line">那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</span><br></pre></td></tr></table></figure>
<p>6.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例 </span></span><br><span class="line"><span class="string">"test"</span>.equals(object);</span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line">object.equals(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure>
<p><strong><em>推荐使用java.util.Objects#equals （JDK7引入的工具类）</em></strong><br>7.所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。<br><strong><em>对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</em></strong></p>
<p>8.关于基本数据类型与包装数据类型的使用标准如下：</p>
<pre><code>1) 所有的POJO类属性必须使用包装数据类型。
2) RPC方法的返回值和参数必须使用包装数据类型。
3） 所有的局部变量推荐使用基本数据类型。</code></pre><p><strong><em>POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。</span><br><span class="line">反例：某业务的交易报表上显示成交总额涨跌情况，即正负x%，x为基本数据类型，</span><br><span class="line">     调用的RPC服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。</span><br><span class="line">     所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。</span><br></pre></td></tr></table></figure>
<p>9.定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">某业务的DO的gmtCreate默认值为newDate();但是这个属性在数据提取时并没有置入具体值，</span><br><span class="line">在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</span><br></pre></td></tr></table></figure>

<p>10.序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。<br><strong><em>注意serialVersionUID不一致会抛出序列化运行时异常。</em></strong><br>11.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。<br>12.POJO类必须写toString方法。使用工具类source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。<br><strong><em>在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</em></strong><br>13.使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"a,b,c,,"</span>;</span><br><span class="line">String[]ary =str.split(<span class="string">","</span>); </span><br><span class="line"><span class="comment">//预期大于3，结果是3</span></span><br><span class="line">System.out.println(ary.length);</span><br></pre></td></tr></table></figure>
<p>14.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。<br>15.类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。<br><strong><em>公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。</em></strong><br>16.setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在 getter/setter方法中，尽量不要增加业务逻辑，增加排查问题难度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> data +<span class="number">100</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">         <span class="keyword">return</span> data- <span class="number">100</span>;</span><br><span class="line">          &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>17.循环体内，字符串的联接方式，使用StringBuilder的append方法进行扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">   str = str+<span class="string">"hello"</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行 append操作，最后通过toString方法返回String对象，造成内存资源浪费。</em></strong><br>18.final可提高程序响应效率，声明成final的情况：<br>1）不需要重新赋值的变量，包括类属性、局部变量。<br>2）对象参数前加final，表示不允许修改引用的指向。<br>3）类方法确定不允许被重写。</p>
<p>19.慎用Object的clone方法来拷贝对象。<br><strong><em>对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝</em></strong></p>
<p>20.类成员与方法访问控制从严<br>1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。<br>2） 工具类不允许有public或default构造方法。<br>3） 类非static成员变量并且与子类共享，必须是protected。<br>4） 类非static成员变量并且仅在本类使用，必须是private。<br>5） 类static成员变量如果仅在本类使用，必须是private。<br>6） 若是static成员变量，必须考虑是否为final。<br>7） 类成员方法只供类内部调用，必须是private。<br>8） 类成员方法只对继承类公开，那么限制为protected。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。</span><br><span class="line">思考：如果是一个private的方法，想删除就删除，可是一个public的Service方法，</span><br><span class="line">或者一个public的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，</span><br><span class="line">变量作用域太大，如果无限制的到处跑，那么你会担心的。</span><br></pre></td></tr></table></figure>

<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><p>1.Map/Set的key为自定义对象时，必须重写hashCode和equals。<br><strong><em>String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</em></strong><br>2.ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException 异常：java.util.RandomAccessSubList cannot be cast tojava.util.ArrayList; 说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。<br>3.在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生ConcurrentModificationException 异常。<br>4.使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。</span></span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">List&lt;String&gt; list =newArrayList&lt;String&gt;(<span class="number">2</span>);     </span><br><span class="line">list.add(<span class="string">"guan"</span>);     </span><br><span class="line">list.add(<span class="string">"bao"</span>);      </span><br><span class="line">String[] array =newString[list.size()];     </span><br><span class="line">array=list.toArray(array);</span><br></pre></td></tr></table></figure>
<p><strong><em>使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。</em></strong><br>5.使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。</span></span><br><span class="line"><span class="comment">// Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</span></span><br><span class="line">String[] str = newString[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span> &#125;;</span><br><span class="line">List list =Arrays.asList(str);</span><br><span class="line"><span class="comment">// 第一种情况：list.add("c");运行时异常。</span></span><br><span class="line"><span class="comment">// 第二种情况：str[0]= "gujin"; 那么list.get(0)也会随之修改。</span></span><br></pre></td></tr></table></figure>
<p>6.泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法。说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹果。<br>7.不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator 方式，如果并发操作，需要对Iterator对象加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">List&lt;String&gt; a =newArrayList&lt;String&gt;();     </span><br><span class="line">a.add(<span class="string">"1"</span>);     </span><br><span class="line">a.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">for</span>(String temp : a)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="string">"1"</span>.equals(temp))&#123;             </span><br><span class="line">      a.remove(temp);         </span><br><span class="line">   &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>这个例子的执行结果会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗?</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例</span></span><br><span class="line">Iterator&lt;String&gt; it =a.iterator(); <span class="keyword">while</span>(it.hasNext())&#123;             </span><br><span class="line">    String temp =  it.next();                       </span><br><span class="line">    <span class="keyword">if</span>(删除元素的条件)&#123;                            </span><br><span class="line">        it.remove();                </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.在JDK7版本以上，Comparator要满足自反性，传递性，对称性，不然Arrays.sort,Collections.sort会报IllegalArgumentException异常。<br>1） 自反性：x，y的比较结果和y，x的比较结果相反。<br>2） 传递性：x&gt;y,y&gt;z,则x&gt;z。<br>3） 对称性：x=y,则x,z比较结果和y，z比较结果相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例：下例中没有处理相等的情况，实际使用中可能会出现异常：</span></span><br><span class="line">newComparator&lt;Student&gt;()&#123;          </span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Studento2)</span></span>&#123;</span><br><span class="line">         returno1.getId() &gt; o2.getId() ? <span class="number">1</span> :-<span class="number">1</span>;         </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.集合初始化时，尽量指定集合初始值大小。说明：ArrayList尽量使用ArrayList(int initialCapacity) 初始化。</p>
<p>10.使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。<br><strong><em>keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key 所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正例：values()返回的是V值集合，是一个list集合对象；</span><br><span class="line">     keySet()返回的是K值集合，是一个Set集合对象；</span><br><span class="line">     entrySet()返回的是K-V值组合集合。</span><br></pre></td></tr></table></figure>

<p>11.【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。<br><strong><em>稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则依次排列的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是 order/sort。</em></strong></p>
<p>12.【参考】利用Set元素唯一的特性，可以快速对另一个集合进行去重操作，避免使用List的 contains方法进行遍历去重操作。</p>
<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><p>1.获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。<br><strong><em>资源驱动类、工具类、单例工厂类都需要注意。</em></strong><br>2.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br><strong><em>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</em></strong><br>3.SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为 static，必须加锁，或者使用DateUtils工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例：注意线程安全，使用DateUtils。亦推荐如下处理：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> finalThreadLocal&lt;DateFormat&gt; df =<span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;      </span><br><span class="line">    <span class="meta">@Override</span>       </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DateFormatinitialValue</span><span class="params">()</span></span>&#123;           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>如果是JDK8的应用，可以使用instant代替Date，Localdatetime代替Calendar，Datetimeformatter代替Simpledateformatter，官方给出的解释：simple beautifulstrong immutable thread-safe。</em></strong><br>4.高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。<br>5.对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。<br><strong><em>线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</em></strong><br>6.并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。</p>
<p>7.多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。</p>
<p>8.线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。Executors各个方法的弊端：<br>1）new FixedThreadPool和newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）new CachedThreadPool和newScheduledThreadPool:主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。<br>9.创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="title">extendsThread</span></span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span></span>&#123;         </span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>);… </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至 countDown方法，直到超时才返回结果。说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。<br>11.避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。说明：Random实例包括java.util.Random 的实例或者 Math.random()实例。<br><strong><em>在JDK7之后，可以直接使用API ThreadLocalRandom，在 JDK7之前，可以做到每个线程一个实例。</em></strong><br>12.通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于jdk5及以上版本），将目标属性声明为 volatile型（比如反例中修改helper的属性声明为privatevolatile Helper helper= null;）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Helper helper= <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper==<span class="keyword">null</span>)</span><br><span class="line">                    helper =newHelper();</span><br><span class="line"></span><br><span class="line">            &#125;      returnhelper; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other functions and members... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13.volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果想取回count++数据，使用如下类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicIntegercount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">count.addAndGet(<span class="number">1</span>); </span><br><span class="line">count++操作如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。</span><br></pre></td></tr></table></figure>
<p>14.注意HashMap的扩容死链，导致CPU飙升的问题。<br>15.ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>1.在一个switch块内，每个case要么通过break/return来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。<br>2.在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements;<br>3.推荐尽量少用else， if-else的方式可以改写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;             </span><br><span class="line">    …            </span><br><span class="line">    <span class="keyword">return</span> obj;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>如果使用要if-else if-else方式表达逻辑，请勿超过3层，超过请使用状态设计模式。</em></strong><br>4.除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，以提高可读性。正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码如下</span></span><br><span class="line">InputStream stream =file.open(fileName,<span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span> (stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">    …</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//反例：</span></span><br><span class="line">    <span class="keyword">if</span> (file.open(fileName, <span class="string">"w"</span>) !=<span class="keyword">null</span>))&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。<br>6.接口入参保护，这种场景常见的是用于做批量操作的接口。<br>7.方法中需要进行参数校验的场景：<br>    1）调用频次低的方法。<br>    2）执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。<br>    3）需要极高稳定性和可用性的方法。<br>    4）对外提供的开放接口，不管是RPC/API/HTTP接口。<br>8.方法中不需要参数校验的场景：<br>    1）极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查。<br>    2）底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。<br>    3）被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p>
<h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><p><strong><em>统一发放模版</em></strong></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>1.在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br><strong><em>不要在方法体内定义：Pattern pattern =Pattern.compile(规则);</em></strong><br>2.避免用Apache Beanutils进行属性的copy。<br><strong><em>Apache BeanUtils性能较差，可以使用其他方案比如SpringBeanUtils, Cglib BeanCopier。</em></strong><br>3.velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（注意，boolean命名不需要加is前缀），会自动调用isXxx()方法。<br><strong><em>注意如果是Boolean包装类对象，优先调用getXxx()的方法。</em></strong><br>4.后台输送给页面的变量必须加$!{var}——中间的感叹号。<br><strong><em>如果var=null或者不存在，那么${var}会直接显示在页面上。</em></strong><br>5.注意 Math.random() 这个方法返回是double类型，注意取值范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。<br>6.获取当前毫秒数：System.currentTimeMillis(); 而不是newDate().getTime(); 说明：如果想获取更加精确的纳秒级时间值，用System.nanoTime。在JDK8中，针对统计时间等场景，推荐使用Instant类。<br>7.尽量不要在vm中加入变量声明、逻辑运算符，更不要在vm模板中加入任何复杂的逻辑。<br>8.任何数据结构的使用都应限制大小。<br><strong><em>这点很难完全做到，但很多次的故障都是因为数据结构自增长，结果造成内存被吃光。</em></strong><br>9.对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。清理这类垃圾代码是技术气场，不要有这样的观念：“不做不错，多做多错”。</p>
<h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>1.不要捕获Java类库中定义的继承自RuntimeException的运行时异常类，如：IndexOutOfBoundsException/NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正例：<span class="keyword">if</span>(obj != <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">反例：<span class="keyword">try</span> &#123; obj.method()&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>2.异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。<br>3.对大段代码进行try-catch，这是不负责任的表现。catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。<br>4.捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。<br>5.有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。<br>6.finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。<br><strong><em>如果JDK7，可以使用try-with-resources方法。</em></strong><br>7.不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。<br>8.捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br><strong><em>如果预期抛的是绣球，实际接到的是铅球，就会产生意外情况。</em></strong><br>9.方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。调用方需要进行null判断防止NPE问题。<br><strong><em>本规约明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回null的情况。</em></strong><br>10.【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：<br>1）返回类型为包装数据类型，有可能是null，返回int值时注意判空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例：如果为null，自动解箱抛NPE。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer 对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）数据库的查询结果可能为null。<br>3）集合里的元素即使isNotEmpty，取出的数据元素也可能为null。<br>4）远程调用返回对象，一律要求进行NPE判断。<br>5）对于Session中获取的数据，建议NPE检查，避免空指针。<br>6）级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>11.【推荐】在代码中使用“抛异常”还是“返回错误码”，对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess、“错误码”、“错误简短信息”。<br><strong><em>关于RPC方法返回方式使用Result方式的理由：</em></strong><br>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。<br>12.定义时区分unchecked / checked 异常，避免直接使用RuntimeException抛出，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DaoException / ServiceException等。<br>13.避免出现重复的代码（Don’tRepeat Yourself），即DRY原则。<br><strong><em>[强制]随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkParam</span><span class="params">(DTOdto)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><p>1.应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger; </span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger=LoggerFactory.getLogger(Abc<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>2.日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。<br>3.应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正例：mppserver应用中单独监控时区转换异常 </span><br><span class="line">如：mppserver_monitor_timeZoneConvert.log</span><br></pre></td></tr></table></figure>
<p><strong><em>推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</em></strong><br>4.对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。<br>说明：logger.debug(“Processingtrade withid: “ + id + “ symbol: “ + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正例：（条件）</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled())&#123;   </span><br><span class="line">logger.debug(<span class="string">"Processing trade with id:"</span> +id + <span class="string">" symbol: "</span> + symbol);  </span><br><span class="line">&#125;      </span><br><span class="line"><span class="comment">// 正例：（占位符）</span></span><br><span class="line">logger.debug(<span class="string">"Processing trade with id:&#123;&#125; andsymbol : &#123;&#125; "</span>, id, symbol);</span><br></pre></td></tr></table></figure>
<p>5.避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;loggername&#x3D;&quot;com.taobao.ecrm.member.config&quot;additivity&#x3D;&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>6.异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上抛。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正例</span><br><span class="line">logger.error(各类参数或者对象toString +&quot;_&quot; + e.getMessage(), e);</span><br></pre></td></tr></table></figure>
<p>7.输出的POJO类必须重写toString方法，否则只输出此对象的hashCode值（地址值），没啥参考意义。<br>8.可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error级别只记录系统逻辑出错、异常、或者重要的错误信息。如非必要，请不要在此场景打出error级别，避免频繁报警。<br>9.谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。<br><strong><em>大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。纪录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</em></strong></p>
<p>10.如果日志用英文描述不清楚，推荐使用中文注释。对于中文UTF-8的日志，在secureCRT 中，set encoding=utf-8；如果中文字符还乱码，请设置：全局&gt;默认的会话设置&gt;外观&gt;字体&gt; 选择字符集gb2312；如果还不行，执行命令：set termencoding=gbk，并且直接使用中文来进行检索。</p>
<h2 id="MYSQL规约"><a href="#MYSQL规约" class="headerlink" title="MYSQL规约"></a>MYSQL规约</h2><p><strong><em>本模块待完善</em></strong></p>
<h3 id="命名规约-1"><a href="#命名规约-1" class="headerlink" title="命名规约"></a>命名规约</h3><h3 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h3><h3 id="SQL规约"><a href="#SQL规约" class="headerlink" title="SQL规约"></a>SQL规约</h3><h2 id="工程规约"><a href="#工程规约" class="headerlink" title="工程规约"></a>工程规约</h2><h3 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h3><p>web-&gt;service-&gt;mapper</p>
<h3 id="平台项目结构"><a href="#平台项目结构" class="headerlink" title="平台项目结构"></a>平台项目结构</h3><p><strong><em>待完善</em></strong></p>
]]></content>
      <categories>
        <category>essay</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis简介</title>
    <url>/framework/mybatis/index/</url>
    <content><![CDATA[<p><strong><em>mybatis简介</em></strong></p>
]]></content>
      <categories>
        <category>framework</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis源码</tag>
      </tags>
  </entry>
  <entry>
    <title>BeanPostProcess解析</title>
    <url>/framework/spring/BeanPostProcess/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>framework</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器及Spring Bean</title>
    <url>/framework/spring/ioc/</url>
    <content><![CDATA[<h2 id="Spring容器"><a href="#Spring容器" class="headerlink" title="Spring容器"></a>Spring容器</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>官网解释</p>
<p><strong><em>The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans.</em></strong></p>
<p>翻译内容:<br>1.Spring IOC容器就是一个org.springframework.context.ApplicationContext的实例化对象<br>2.容器负责了实例化，配置以及装配一个bean</p>
<p>总结:</p>
<ul>
<li>代码层面:Spring容器是实现了ApplicationContext接口的对象。</li>
<li>功能层面:Spring容器是Spring框架的核心,作用是管理对象。容器会创建对象,连接对象,并管理它们整个生命周期(创建到销毁).</li>
</ul>
<h3 id="容器如何工作"><a href="#容器如何工作" class="headerlink" title="容器如何工作"></a>容器如何工作</h3><p><img src="/framework/spring/ioc/springioc.png" alt="官网介绍"></p>
<p><strong><em>Spring容器通过我们提交的POJO对象以及配置元数据产生一个充分配置的可以使用的系统。这里说的配置元数据，实际上我们就是我们提供的XML配置文件，或者通过注解方式提供的一些配置信息</em></strong></p>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><h3 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h3><h4 id="构造器创建"><a href="#构造器创建" class="headerlink" title="构造器创建"></a>构造器创建</h4><p>1.无参构造器<br>使用空构造器进行定义，使用此种方式，class属性指定的类必须有空构造器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"people"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zzf.entity.People"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>2.有参构造器<br>使用<constructor-arg>标签指定构造器参数值，其中index表示位置，value表示常量值，也可以指定引用，指定引用使用ref来引用另一个Bean定义.</constructor-arg></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"people2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zzf.entity.People"</span>&gt;</span><br><span class="line">    &lt;constructor-arg index="0" value="zzf"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index="1" value="18"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index="2" ref="collection"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="静态工厂方法创建"><a href="#静态工厂方法创建" class="headerlink" title="静态工厂方法创建"></a>静态工厂方法创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//getter setter 方法省略....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleFactoty</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> People <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> People();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"people3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zzf.factory.PeopleFactory"</span> </span><br><span class="line">    factory-method=<span class="string">"newInstance"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="实例工厂方法创建"><a href="#实例工厂方法创建" class="headerlink" title="实例工厂方法创建"></a>实例工厂方法创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//getter setter 方法省略....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleFactoty1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> People();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"peopleFactoty1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.zzf.factory.PeopleFactoty1"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean name=<span class="string">"people3"</span>  factory-bean=<span class="string">"peopleFactoty1"</span></span><br><span class="line">    factory-method=<span class="string">"newInstance"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h3><p>1.实例化容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext applicationContext &#x3D;</span><br><span class="line">                new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);</span><br><span class="line">        People people &#x3D; applicationContext.getBean(People.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2.org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance<br><img src="/framework/spring/ioc/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95.png" alt="断点调试"><br>3.源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取这个bean的class属性，确保beanDefinition中beanClass属性已经完成解析</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="comment">//对象是否可以创建异常判断</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过FactoryMethod实例化这个bean</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这段代码都是在通过构造函数实例化这个Bean,分两种情况，</span></span><br><span class="line">    <span class="comment">//一种是通过默认的无参构造，</span></span><br><span class="line">    <span class="comment">//一种是通过推断出来的构造函数</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推断合适的构造方法集合</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有特殊处理默认使用无参构造器创建</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>framework</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring核心概念（源码相关）</title>
    <url>/framework/spring/core/</url>
    <content><![CDATA[<p><strong><em>本文主要讲解Spring源码中经常看到的类的作用，中间会有会有部分代码讲解，各模块的具体源码会写在后面的文章中</em></strong></p>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p><em>BeanDefinition中保存了我们Bean的信息。声名式bean的定义下面三种方式</em><br>1.<bean> xml配置<br>2.@Bean<br>3.@Component<br><em>spring 在读取bean配置信息后会给bean配置生成对应的BeanDefinition象对象存储类信息供spring生产bean使用。我们也可以直接使用beanDefinition生成一个bean。</em></bean></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">     <span class="comment">// 获取beanDefinition对象</span></span><br><span class="line">     AbstractBeanDefinition beanDefinition = </span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">     <span class="comment">// 写入需要生产的bean</span></span><br><span class="line">     beanDefinition.setBeanClass(People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     <span class="comment">// 注册到spring容器中</span></span><br><span class="line">     applicationContext.registerBeanDefinition(<span class="string">"myBean"</span>,beanDefinition);</span><br><span class="line">     <span class="comment">// 刷新容器</span></span><br><span class="line">     applicationContext.refresh();</span><br><span class="line">     <span class="comment">// 获取bean</span></span><br><span class="line">     System.out.println(applicationContext.getBean(People<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">     System.out.println(applicationContext.getBean(<span class="string">"myBean"</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//spring.bean.People@1ce92674</span></span><br><span class="line"><span class="comment">//spring.bean.People@1ce92674</span></span><br></pre></td></tr></table></figure>
<h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><p><em>顾名思义，这个类的作用就是读取类配置。它主有很多实现类，例如XmlBeanDefinitionReader 读取的就是<bean>方式配置</bean></em></p>
<h3 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"spring.bean.People"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">  <span class="comment">//创建beanDefinitionReader</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">  <span class="comment">//通过xml文件加载bean到applicationContext 返回值为读取到bean的数量</span></span><br><span class="line">  <span class="keyword">int</span> i = beanDefinitionReader.loadBeanDefinitions(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h3><p><em>注意:这个类并不是解析被@Bean,@Component注解修饰等类,而是解析需要加载的类的一些配置信息如:@Scope,@Lazy</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">//创建beanDefinitionReader </span></span><br><span class="line">    AnnotatedBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(applicationContext);</span><br><span class="line">    <span class="comment">//通过xml文件加载bean到applicationContext 返回值为读取到bean的数量</span></span><br><span class="line">    beanDefinitionReader.registerBean(People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">    System.out.println(applicationContext.getBean(<span class="string">"people"</span>));</span><br><span class="line">    System.out.println(applicationContext.getBean(<span class="string">"people"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// spring.bean.People@5ae50ce6</span></span><br><span class="line"><span class="comment">//  spring.bean.People@6f96c77</span></span><br></pre></td></tr></table></figure>
<p><em>*People.class设置它的作用范围为原型。从结果上面可看出两次得到的People对象确实是不同的</em></p>
<h3 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h3><p><em>通过包扫描注解解析@Component（@Bean注解不会bei扫描）</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spring.bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">   ClassPathBeanDefinitionScanner classPathBeanDefinitionScanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(applicationContext);</span><br><span class="line">   classPathBeanDefinitionScanner.scan(<span class="string">"spring.bean"</span>);</span><br><span class="line">   applicationContext.refresh();</span><br><span class="line">   System.out.println(applicationContext.getBean(People<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// spring.bean.People@74fe5c40</span></span><br></pre></td></tr></table></figure>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p><em>Spring中有很多种BeanFactory,本文以它中比较核心的实现类DefaultListableBeanFactory讲解</em><br><img src="/framework/spring/core/DefaultListableBeanFactory.png" alt><br><em>DefaultListableBeanFactory实现了很多接口表示拥有很多功能</em></p>
<ul>
<li>AliasRegistry:支持别名功能，一个名字可以对应多个别名</li>
<li>BeanDefinitionRegistry: 可以注册、保存、移除、获取某个BeanDefinition</li>
<li>BeanFactory：可以根据bean的名字、类型、别名获取Bean对象</li>
<li>SingletonBeanRegistry: 可以直接注册、获取单例bean</li>
<li>SimpleAliasRegistry：它是一个类，实现了AliasRegistry接口中所定义的功能，支持别名功能</li>
<li>ListableBeanFactory：在BeanFactory的基础上，增加了其他功能，可以获取所有BeanDefinition的beanNames，可以根据某个类型获取对应的beanNames，可以根据某个类型获取{类型：对应的Bean}的映射关系</li>
<li>HierarchicalBeanFactory：在BeanFactory的基础上，添加了获取父BeanFactory的功能</li>
<li>DefaultSingletonBeanRegistry：它是一个类，实现了SingletonBeanRegistry接口，拥有了直接注册、获取某个单例Bean的功能</li>
<li>ConfigurableBeanFactory：在HierarchicalBeanFactory和SingletonBeanRegistry的基础上，添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL表达式解析器（表示该BeanFactory可以解析EL表达式）、设置类型转化服务（表示该BeanFactory可以进行类型转化）、可以添加BeanPostProcessor（表示该BeanFactory支持Bean的后置处理器），可以合并BeanDefinition，可以销毁某个Bean等等功能</li>
<li>FactoryBeanRegistrySupport：支持了FactoryBean的功能</li>
<li>AutowireCapableBeanFactory：是直接继承了BeanFactory，在BeanFactory的基础上，支持在创建Bean的过程中能对Bean进行自动装配</li>
<li>AbstractBeanFactory：实现了ConfigurableBeanFactory接口，继承了FactoryBeanRegistrySupport，这个BeanFactory的功能已经很全面了，但是不能自动装配和获取beanNames</li>
<li>ConfigurableListableBeanFactory：继承了ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory</li>
<li>AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory，拥有了自动装配的功能</li>
<li>DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口，所以DefaultListableBeanFactory的功能很强大</li>
</ul>
<p><strong><em>通过以上分析，我们可以知道，通过DefaultListableBeanFactory我们可以做很多事情</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">beanDefinition.setBeanClass(People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// 注册BeanDefinition</span></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">"people"</span>, beanDefinition);</span><br><span class="line"><span class="comment">// 注册别名</span></span><br><span class="line">beanFactory.registerAlias(<span class="string">"people"</span>, <span class="string">"people1"</span>);</span><br><span class="line"><span class="comment">// 注册BeanPostProcessor</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LubanBeanPostProcessor());</span><br><span class="line"><span class="comment">// 获取Bean对象</span></span><br><span class="line">System.out.println(beanFactory.getBean(<span class="string">"people1"</span>));</span><br><span class="line"><span class="comment">// 根据类型获取beanNames</span></span><br><span class="line">System.out.println(beanFactory.getBeanNamesForType(People<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p><img src="/framework/spring/core/applicationContext.png" alt></p>
<p><em>ApplicationContext是一个接口,可以把它理解成一个特殊的BeanFactory</em></p>
<ul>
<li>HierarchicalBeanFactory：拥有获取父BeanFactory的功能</li>
<li>ListableBeanFactory：拥有获取beanNames的功能</li>
<li>ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）</li>
<li>EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</li>
<li>ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</li>
<li>MessageSource：拥有国际化功能</li>
</ul>
<p><strong><em>下面用两个比较重要的实现类进行讲解</em></strong></p>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p><img src="/framework/spring/core/AnnotationConfigApplicationContext.png" alt>     </p>
<ul>
<li>ConfigurableApplicationContext：继承了ApplicationContext接口，增加了，添加事件监听器、添加BeanFactoryPostProcessor、设置Environment，获取ConfigurableListableBeanFactory等功能。</li>
<li>AbstractApplicationContext：实现了ConfigurableApplicationContext接口</li>
<li>GenericApplicationContext：继承了AbstractApplicationContext，实现了BeanDefinitionRegistry接口，拥有了所有ApplicationContext的功能，并且可以注册BeanDefinition，注意这个类中有一个属性(DefaultListableBeanFactory beanFactory)</li>
<li>AnnotationConfigRegistry：可以单独注册某个为类为BeanDefinition（可以处理该类上的@Configuration注解，处理@Bean注解），同时可以扫描。</li>
<li>AnnotationConfigApplicationContext：继承了GenericApplicationContext，实现了AnnotationConfigRegistry接口，拥有了以上所有的功能。</li>
</ul>
<h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><p><img src="/framework/spring/core/ClassPathXmlApplicationContext.png" alt><br><em>它也是继承了AbstractApplicationContext，但是相对于AnnotationConfigApplicationContext而言，功能没有AnnotationConfigApplicationContext强大，比如不能注册BeanDefinition</em></p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p><em>定义一个MessageSource</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">    <span class="comment">//设置语言配置文件前缀 如messages-en_CN、messages-en</span></span><br><span class="line">    messageSource.setBasename(<span class="string">"messages"</span>);</span><br><span class="line">    <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>使用</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出对应语言配置文件中的信息</span></span><br><span class="line">annotationConfigApplicationContext.getMessage(<span class="string">"test"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Locale(<span class="string">"en_CN"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p><em>ApplicationContext还拥有资源加载的功能，比如，可以直接利用ApplicationContext获取某个文件的内容</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Resource resource = annotationConfigApplicationContext.getResource(<span class="string">"file://D:\\IdeaProjects\\spring-framework\\zzf\\src\\main\\java\\com\\zzf\\entity\\People.java"</span>);</span><br><span class="line">System.out.println(resource.contentLength());</span><br></pre></td></tr></table></figure>
<p><em>classpath获取</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = annotationConfigApplicationContext.getResource(<span class="string">"classpath:com/zzf/entity/People.class"</span>);</span><br><span class="line">System.out.println(resource.contentLength());</span><br></pre></td></tr></table></figure>
<p><em>一次性获取多个</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource[] resources = annotationConfigApplicationContext.getResources(<span class="string">"classpath:com/zzf/service/*.class"</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource.contentLength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取运行时环境"><a href="#获取运行时环境" class="headerlink" title="获取运行时环境"></a>获取运行时环境</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取JVM所允许的操作系统的环境</span></span><br><span class="line">annotationConfigApplicationContext.getEnvironment().getSystemEnvironment();</span><br><span class="line"><span class="comment">// 获取JVM本身的一些属性，包括-D所设置的</span></span><br><span class="line">annotationConfigApplicationContext.getEnvironment().getSystemProperties();</span><br><span class="line"><span class="comment">// 还可以直接获取某个环境或properties文件中的属性</span></span><br><span class="line">annotationConfigApplicationContext.getEnvironment().getProperty(<span class="string">"xxx"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h3><p><em>定义一个事件监听器</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationListener <span class="title">applicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"接收到了一个事件"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  发布事件</span></span><br><span class="line">annotationConfigApplicationContext.publishEvent(<span class="string">"事件XXX"</span>);</span><br></pre></td></tr></table></figure>

<p><em>发布事件</em></p>
<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><h3 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h3><p><em>JDK中提供的类型转化工具类</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToPeoplePropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line">        people.setName(text);</span><br><span class="line">        <span class="keyword">this</span>.setValue(people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringToPeoplePropertyEditor propertyEditor = <span class="keyword">new</span> StringToPeoplePropertyEditor();</span><br><span class="line">propertyEditor.setAsText(<span class="string">"1"</span>);</span><br><span class="line">People value = (People) propertyEditor.getValue();</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>
<p><em>Spring中注册PropertyEditor</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomEditorConfigurer <span class="title">customEditorConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CustomEditorConfigurer customEditorConfigurer = <span class="keyword">new</span> CustomEditorConfigurer();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; propertyEditorMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 添加自定义转化器</span></span><br><span class="line">    propertyEditorMap.put(People<span class="class">.<span class="keyword">class</span>, <span class="title">StringToPeoplePropertyEditor</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    customEditorConfigurer.setCustomEditors(propertyEditorMap);</span><br><span class="line">    <span class="keyword">return</span> customEditorConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  会把"true"设置为people的name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"true"</span>)</span><br><span class="line">    People test;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p><em>Spring中提供的类型转化服务，它比PropertyEditor更强大</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义转换器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToPeopleConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sourceType.getType().equals(String<span class="class">.<span class="keyword">class</span>) &amp;&amp; <span class="title">targetType</span>.<span class="title">getType</span>().<span class="title">equals</span>(<span class="title">People</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(String<span class="class">.<span class="keyword">class</span>, <span class="title">People</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line">        people.setName((String)source);</span><br><span class="line">        <span class="keyword">return</span> people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常使用</span></span><br><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToPeopleConverter());</span><br><span class="line">People value = conversionService.convert(<span class="string">"1"</span>, People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>
<p><em>Spring 中注入ConversionService</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">    conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="keyword">new</span> StringToPeopleConverter()));</span><br><span class="line">    <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeConverter"><a href="#TypeConverter" class="headerlink" title="TypeConverter"></a>TypeConverter</h3><p><em>整合了PropertyEditor和ConversionService的功能，Spring内部使用</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleTypeConverter typeConverter = <span class="keyword">new</span> SimpleTypeConverter();</span><br><span class="line">typeConverter.registerCustomEditor(People<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">StringToPeoplePropertyEditor</span>())</span>;</span><br><span class="line">People value = typeConverter.convertIfNecessary(<span class="string">"1"</span>, People<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p><em>Bean的后置处理器，可以在创建每个Bean的过程中进行干涉，是属于BeanFactory中一个属性，Bean的生命周期文章中详细讲。</em></p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p><em>Bean工厂的后置处理器，是属于ApplicationContext中的一个属性，是ApplicationContext在实例化一个BeanFactory后，可以利用BeanFactoryPostProcessor继续处理BeanFactory。</em><br><em>程序员可以通过BeanFactoryPostProcessor间接的设置BeanFactory，比如上文中的CustomEditorConfigurer就是一个BeanFactoryPostProcessor，我们可以通过它向BeanFactory中添加自定义的PropertyEditor。</em></p>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p><em>允许程序员自定义一个对象通过FactoryBean间接的放到Spring容器中成为一个Bean。</em><br><strong><em>那么它和@Bean的区别是什么？因为@Bean也可以自定义一个对象，让这个对象成为一个Bean。</em></strong><br><em>区别在于利用FactoryBean可以更加强大，因为你通过定义一个XxFactoryBean的类，可以再去实现Spring中的其他接口，比如如果你实现了BeanFactoryAware接口，那么你可以在你的XxFactoryBean中获取到Bean工厂，从而使用Bean工厂做更多你想做的，而@Bean则不行。</em></p>
]]></content>
      <categories>
        <category>framework</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码解析</title>
    <url>/java/container/ArrayList/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>  <em>实现了三个标记接口: RandomAccess, Cloneable, java.io.Serializable</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>


<h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>   <em>支持随机访问（基于下标）,为了能够更好地判断集合是ArrayList还是LinkedList，从而能够更好选择更优的遍历方式，提高性能！</em></p>
<h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>   <em>支持拷贝：实现Cloneable接口，重写clone方法、方法内容默认调用父类的clone方法。</em><br>1.浅拷贝<br>   <em>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">               Study study = (Study) <span class="keyword">super</span>.clone();</span><br><span class="line">               <span class="keyword">return</span> study;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>2.深拷贝<br>   <em>对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制内容，这是深拷贝</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Study s = (Study) <span class="keyword">super</span>.clone();</span><br><span class="line">    s.setScore(<span class="keyword">this</span>.score.clone());</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>java的传参有基本类型和引用类型传参,参数传递时拷贝的都是栈中的内容。此处大概分为三种情况</em></p>
<p>1.基本类型,存储在栈中所以拷贝的就是真实的值，修改后不影响原值<br>2.引用类型:栈中内容为对象引用,拷贝的也为引用 修改改变的是引用所指向的对象,由于引用的同一个对象，所以元对象改变了<br>3.String:虽然String也是引用类型 但于String是不可变对象 在修改时会讲引用指向一个新的对象，所已他们的引用变得不同了，当然不会改变原值</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p><em>序列化：将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据，在Java中的这个Serializable接口其实是给jvm看的，通知jvm，我不对这个类做序列化了，你(jvm)帮我序列化就好了。如果我们没有自己声明一个serialVersionUID变量,接口会默认生成一个serialVersionUID，默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常（每次序列化都会重新计算该值）</em></p>
<h3 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h3><p><em>继承了AbstractList ，说明它是一个列表，拥有相应的增，删，查，改等功能。</em></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>为什么继承了 AbstractList 还需要 实现List 接口？</p>
<p><em>1、在StackOverFlow 中：传送门 得票最高的答案的回答者说他问了当初写这段代码的 Josh Bloch，得知这就是一个写法错误。<br> I’ve asked Josh Bloch, and he informs me that it was a mistake.He used to think, long ago, that there was some value in it,<br> but he since “saw the light”.Clearly JDK maintainers haven’t considered this to be worth backing out later.</em></p>
<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化版本号（类文件签名），如果不写会默认生成</span></span><br><span class="line"><span class="comment"> * 类内容的改变会影响签名变化，导致反序列化失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果实例化时未指定容量，则在初次添加元素时会进行扩容使用此容量作为数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * static修饰，所有的未指定容量的实例(也未添加元素)共享此数组</span></span><br><span class="line"><span class="comment"> * 两个空的数组有什么区别呢？</span></span><br><span class="line"><span class="comment"> * 就是第一次添加元素时知道该 elementData 从空的构造函数还是有参构造函数被初始化的。</span></span><br><span class="line"><span class="comment"> * 以便确认如何扩容。空的构造器则初始化为10，有参构造器则按照扩容因子扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arrayList真正存放元素的地方，长度大于等于size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arrayList中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造器，构造一个容量大小为 10 的空的 list 集，</span></span><br><span class="line"><span class="comment"> * 但构造函数只是给 elementData 赋值了一个空的数组，</span></span><br><span class="line"><span class="comment"> * 是在第一次添加元素时容量扩大至 10 的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当使用无参构造函数时是把DEFAULTCAPACITY_EMPTY_ELEMENTDATA 赋值给 elementData。</span></span><br><span class="line"><span class="comment"> * 当initialCapacity 为零时则是把 EMPTY_ELEMENTDATA 赋值给 elementData。 </span></span><br><span class="line"><span class="comment"> * 当initialCapacity大于零初始化一个大小为initialCapacity的object数组并赋值给elementData。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Collection 转化为数组，数组长度赋值给 size。 </span></span><br><span class="line"><span class="comment"> * 如果 size 不为零，则判断 elementData 的 class 类型是否为 ArrayList，不是的话则做一次转换。</span></span><br><span class="line"><span class="comment"> * 如果 size 为零，则把 EMPTY_ELEMENTDATA 赋值给 elementData，相当于new ArrayList(0)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指向空数组</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="尾部插入-默认"><a href="#尾部插入-默认" class="headerlink" title="尾部插入(默认)"></a>尾部插入(默认)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次添加元素到集合中时都会先确认下集合容量大小。然后将 size 自增 1赋值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断如果 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * 就取 DEFAULT_CAPACITY 和 minCapacity 的最大值也就是 10。</span></span><br><span class="line"><span class="comment"> * 这就是 EMPTY_ELEMENTDATA 与DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的区别所在。</span></span><br><span class="line"><span class="comment"> * 同时也验证了上面的说法：使用无参构造函数时是在第一次添加元素时初始化容量为 10 的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对modCount自增1,记录操作次数,如果minCapacity大于elementData的长度,则对集合进行扩容,</span></span><br><span class="line"><span class="comment"> * 第一次添加元素时 elementData 的长度为零</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>插入性能与linkedList对比</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdk8.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arrayList 提前指定容量大小 插入性能对比linkedList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangzhifeng </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EffectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不指定下标插入</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">10000000</span>;</span><br><span class="line">        <span class="comment">//指定容量时</span></span><br><span class="line">        List arrayList = <span class="keyword">new</span> ArrayList(length);</span><br><span class="line"></span><br><span class="line">        List linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">long</span> start5 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;length;i++)&#123;</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end5 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"arrayList:"</span>+(end5-start5));</span><br><span class="line">        <span class="keyword">long</span> start6 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;length;i++)&#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end6 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"linkedList:"</span>+(end6-start6));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果</span></span><br><span class="line">    <span class="comment">//arrayList:1876</span></span><br><span class="line">    <span class="comment">//linkedList:8040</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>arrayList涉及扩容，会消耗性能但是如果提前指定容量，会提升性能，可以达到与linkedList相当，甚至超越</strong></p>
<hr>
<h3 id="指定下标插入"><a href="#指定下标插入" class="headerlink" title="指定下标插入"></a>指定下标插入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下标越界检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上尾部插入判断扩容,记录操作数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依次复制插入位置及后面的数组元素，到后面一格，不是移动，</span></span><br><span class="line"><span class="comment">     * 因此复制完后，添加的下标位置和下一个位置指向对同一个对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">            size - index);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再将元素赋值给该下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>时间复杂度为O(n)，与移动的元素个数正相关</strong></p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取当前数组长度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 默认将扩容至原来容量的 1.5 倍</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果1.5倍太小的话，则将我们所需的容量大小赋值给newCapacity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果1.5倍太大或者我们需要的容量太大，</span></span><br><span class="line"><span class="comment">             * 那就直接拿 newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ?</span></span><br><span class="line"><span class="comment">             * Integer.MAX_VALUE : MAX_ARRAY_SIZE 来扩容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">                newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 然后将原数组中的数据复制到大小为 newCapacity 的新数组中，并将新数组赋值给 elementData。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要的长度溢出 抛OOM异常</span></span><br><span class="line"><span class="comment">         * 大于数组长度最大值直接取Integer.max</span></span><br><span class="line"><span class="comment">         * 否则拿最大长度MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">            <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                    Integer.MAX_VALUE :</span><br><span class="line">                    MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查 index 是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 操作数+1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断要删除的元素是否是最后一个位</span></span><br><span class="line"><span class="comment">         * 如果 index 不是最后一个，就从 index + 1 开始往后所有的元素都向前拷贝一份。</span></span><br><span class="line"><span class="comment">         * 然后将数组的最后一个位置空,如果 index 是最后一个元素那么就直接将数组的最后一个位置空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 让指针最后指向空，进行gc</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当我们调用 remove(Object o) 时，会把 o 分为是否为空来分别处理。</span></span><br><span class="line"><span class="comment">     * 对数组做遍历，找到第一个与 o 对应的下标 index</span></span><br><span class="line"><span class="comment">     * 调用 fastRemove 方法，删除下标为 index 的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fastRemove(int index) 方法和 remove(int index) 方法基本全部相同。</span></span><br><span class="line"><span class="comment">     * 它不用校验index的合法性和记录删除的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList 内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表下一个要访问的元素下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表上一个要访问的元素下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表对 ArrayList 修改次数的期望值，初始值为 modCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果下一个元素的下标等于集合的大小 ，就证明到最后了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断expectedModCount和modCount是否相等,ConcurrentModificationException</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="comment">//对 cursor 进行判断，看是否超过集合大小和数组长度</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="comment">// 自增 1。开始时，cursor = 0，lastRet = -1；每调用一次next方法，cursor和lastRet都会自增1。</span></span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将cursor赋值给lastRet，并返回下标为 lastRet 的元素</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断 lastRet 的值是否小于 0</span></span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="comment">//判断expectedModCount和modCount是否相等,ConcurrentModificationException</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用 ArrayList 的 remove 方法删除下标为 lastRet 的元素</span></span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="comment">//将 lastRet 赋值给 curso</span></span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            <span class="comment">//将 lastRet 重新赋值为 -1，并将 modCount 重新赋值给 expectedModCount。</span></span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>remove 方法的弊端。<br> 1、只能进行remove操作，add、clear 等 Itr 中没有。<br> 2、调用 remove 之前必须先调用 next。因为 remove 开始就对 lastRet 做了校验。而 lastRet 初始化时为 -1。<br> 3、next 之后只可以调用一次 remove。因为 remove 会将 lastRet 重新初始化为 -1</em></p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p><em>fail-fast机制是java集合中的一种错误机制。当使用迭代器迭代时，如果发现集合有修改，则快速失败做出响应，抛出ConcurrentModificationException异常。这种修改有可能是其它线程的修改，也有可能是当前线程自己的修改导致的，比如迭代的过程中直接调用remove()删除元素等。另外，并不是java中所有的集合都有fail-fast的机制。比如，像最终一致性的ConcurrentHashMap、CopyOnWriterArrayList等都是没有fast-fail的。<br> fail-fast是怎么实现的：<br> ArrayList、HashMap中都有一个属性叫modCount，每次对集合的修改这个值都会加1，在遍历前记录这个值到expectedModCount中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。<br> 底层数组存/取元素效率非常的高(get/set)，时间复杂度是O(1)，而查找（比如：indexOf，contain），插入和删除元素效率不太高，时间复杂度为O(n)。<br> 插入/删除元素会触发底层数组频繁拷贝，效率不高，还会造成内存空间的浪费，解决方案：linkedList<br> 查找元素效率不高，解决方案：HashMap（红黑树）</em></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.创建时指定最好初始长度,减少扩容次数提升效率<br>2.arrayList.subList(beginIndex,endIndex) 返回其内部类 通过指定偏移量操作原对象。（源对象不可变此处有fast-fail检查）<br>3.属性 modCount 每次添加删除元素 +1 fast-fail 检查<br>4.List unmodifiableList = Collections.unmodifiableList(list); 不可变list 原对象可变   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器  </span></span><br><span class="line">UnmodifiableList(List&lt;? extends E&gt; list) &#123;</span><br><span class="line">    <span class="keyword">super</span>(list);</span><br><span class="line">    <span class="keyword">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get 操作的原对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line"><span class="comment">//变更操作直接抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.Arrays.asList(T..) 返回的是Arrays内部类。若传入的数组为基本类型,返回的list长度一直为1。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(array);</span><br><span class="line"><span class="comment">//list.size() = 3</span></span><br><span class="line"><span class="keyword">int</span>[] array1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List list1 = Arrays.asList(array1);</span><br><span class="line"><span class="comment">// list.size() = 1</span></span><br><span class="line"><span class="comment">//基本类型不支持范型，此处会变成int[1][]</span></span><br><span class="line"><span class="comment">// debug 自测</span></span><br></pre></td></tr></table></figure>

<p>6.List的最大长度为什么为 Integer.max-8</p>
]]></content>
      <categories>
        <category>java</category>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>并发应该学习什么</title>
    <url>/java/concurrent/introduce/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="并发编程的本质-多线程编程"><a href="#并发编程的本质-多线程编程" class="headerlink" title="并发编程的本质(多线程编程)"></a>并发编程的本质(多线程编程)</h3><ol>
<li>同步: 线程间的协作</li>
<li>互斥: 独占锁</li>
<li>分工: 大任务拆解<h3 id="并发学什么"><a href="#并发学什么" class="headerlink" title="并发学什么"></a>并发学什么</h3></li>
<li>JMM模型 java线程内存模型 <ul>
<li>特性:原子性、有序性、可见性</li>
<li>硬件:机械同感</li>
</ul>
</li>
<li>线程 内核级线程<br>2.1 new Thread() 和普通对象的区别?<br>thread.start() 是本地方法即调用JVM的c++方法<br>2.2 为什么java 线程是内核级线程<br>-JVM不具有调度CPU的权限 new Thread()只是一个java对象start() 实际调用操作系统中p_thread方法。java 线程只是作用与线程绑定.过程为javaThread–osThread–内核线程（p_thread）<br>2.3 线程池-线程复用<br>由于java线程需要与内核线程进行绑定，创建、连接、销毁都损性能，所以线程池就是为了减少开销提升性能。<br>2.4 锁机制 （加锁是为了序列化的访问临界资源）<br> JVM内置锁: synchronized,包含四种状态 无锁、偏向锁、轻量级锁、重量级锁。（锁膨胀过程、object monitor 机制）<br> JUC包: 独占锁、共享锁、读写锁，公平锁、非公平锁（AQS）<br> 等待唤醒机制（wait/notify、park/unpark<br>2.5 工具类&amp;并发容器<br>2.6 并行 （forkjoin）<br>2.7 并发设计模式<br>不变性、copyonwrite<br>等待唤醒机制<br>生产者消费者模式<h3 id="并发的风险"><a href="#并发的风险" class="headerlink" title="并发的风险"></a>并发的风险</h3></li>
<li>性能问题: 上下文频繁切换<br>线程切换是时候需要对线程1的状态进行保存例如 程序执行的行号、变量值等，而线程2需要恢复线程上一次获取到cpu的执行状态</li>
<li>活跃性问题:<ul>
<li>死锁: 线程相互等待。例子 面试官问:你给我解释下死锁。你答:你录取我我就告诉你。</li>
<li>活锁: 线程相互谦让。例子 过马路，你迎面遇到一辆车，两个人相互让道，但每次都没让开。</li>
<li>饥饿: 一个线程执行时优先级高 反复获取资源导致其他线程不能执行</li>
</ul>
</li>
<li>线程安全<br>加锁、三大特性、happens-before(八大原则+六条推论)</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>JAVAIO模型之NIO、BIO、AIO</title>
    <url>/java/io/iomodul/</url>
    <content><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>io模型就是各种数据使用相应通道进行发送和接收。Java共支持三种网络编程IO模式 BIO、NIO、AIO</p>
<h2 id="BIO-（Blocking-IO）"><a href="#BIO-（Blocking-IO）" class="headerlink" title="BIO （Blocking IO）"></a>BIO （Blocking IO）</h2><p>同步阻塞模型,一个客户端连接对应一个处理线程。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<p>1.IO代码里read是阻塞操作，如果连接不做读写操作会导致线程阻塞，浪费资源<br>2.如果读写很多，会导致服务器线程过多，压力太大。</p>
</blockquote>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>BIO适用于连接数目较小且固定的架构，这种方式对服务器资源的要求比较高，但是程序简单易理解。<br><img src="https://img-blog.csdnimg.cn/20210222112406179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt></p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 风信子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"等待连接..."</span>);</span><br><span class="line">            <span class="comment">//阻塞方法</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket =  serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"有客户端连接..."</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        handler(socket);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前线程:"</span>+Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">"准备read..."</span>);</span><br><span class="line">        <span class="comment">// 接受客户端数据没有就阻塞</span></span><br><span class="line">        <span class="keyword">int</span> read = socket.getInputStream().read(bytes);</span><br><span class="line">        <span class="keyword">if</span>(read!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"接收到客户端的信息为:"</span>+<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">            System.out.println(<span class="string">"当前线程:"</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">        socket.getOutputStream().write(<span class="string">"hello client"</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 风信子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">9000</span>);</span><br><span class="line">        socket.getOutputStream().write(<span class="string">"Hello BIO"</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">        System.out.println(<span class="string">"数据发送结束!"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 接受服务器传回的数据</span></span><br><span class="line">        socket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="string">"接收到的信息为:"</span>+<span class="keyword">new</span> String(bytes));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO-Non-Blocking-IO"><a href="#NIO-Non-Blocking-IO" class="headerlink" title="NIO (Non Blocking IO)"></a>NIO (Non Blocking IO)</h2><p>同步非阻塞模型,服务实现模型为一个线程可以处理多个连接(请求),客户端的连接都会注册到<strong>多路复用器selector</strong>上面，多路复用轮询到连接用IO请求就进行处理，I/O 多路复用底层一般用的是Linux API （select,poll,epoll）来实现，区别见下面表格:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">select</th>
<th align="center">poll</th>
<th align="center">epoll（jdk1.5及以上）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作方式</td>
<td align="center">遍历</td>
<td align="center">遍历</td>
<td align="center">回调</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="center">数组</td>
<td align="center">链表</td>
<td align="center">哈希表</td>
</tr>
<tr>
<td align="center">IO效率</td>
<td align="center">每次调用进行线性遍历，时间复杂度为O（n）</td>
<td align="center">每次调用进行线性遍历，时间复杂度为O（n）</td>
<td align="center">事件通知方式，每当有io事件就绪，系统注册的回调函数就会被调用，时间复杂度为O(1)</td>
</tr>
<tr>
<td align="center">最大连接</td>
<td align="center">有上限</td>
<td align="center">无上限</td>
<td align="center">无上限</td>
</tr>
</tbody></table>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>NIO 适用于连接数目多且连接时间短（轻量级）的架构，比如聊天服务器，弹幕系统，服务间通信。编程比较复杂。jdk1.4开始支持。<br><img src="https://img-blog.csdnimg.cn/20210222143046287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>NIO 有三大组件: Channel（通道）、Buffer（缓冲区），Selector（选择器）<br><img src="https://img-blog.csdnimg.cn/20210222143616227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>channel 类似于流，每个channel对应一个buffer缓冲区，buffer底层是个数组</li>
<li>channel 会注册到selector上面，由selector 根据channel读写事件的发生将其交给空闲的线程处理。</li>
<li><strong>selector 可以对应一个或多个线程</strong></li>
<li>NIO 的Buffer和Channel都是既可以读也可以写的<h3 id="NIO-服务端程序分析"><a href="#NIO-服务端程序分析" class="headerlink" title="NIO 服务端程序分析"></a>NIO 服务端程序分析</h3></li>
<li>创建一个ServerSocketChannel和Selector,将serverSocketChannel注册到Selector上</li>
<li>selector通过select()方法监听channel事件,当客户端连接时selector监听到连接事件,获取到ServerSocketChannel注册时绑定的selectionKey</li>
<li>selectionKey通过channel()方法可以获取绑定的ServerSocketChannel</li>
<li>ServerSocketChannel通过accept()方法得到SocketChannel</li>
<li>将SocketChannel注册到Selector上,关心read事件</li>
<li>注册后返回一个SelectionKey,会和该SocketChannel关联</li>
<li>selector继续通过select()方法监听事件,当客户端发送数据给服务端,selector监听到read事件,获取到SocketChannel注册时绑定的selectionKey</li>
<li>selectionKey通过channel()方法可以获取绑定的socketChannel</li>
<li>将socketChannel里的数据读取出来</li>
<li>用socketChannel将服务端数据写回客户端</li>
</ol>
<p><strong><em>*总结</em></strong>：NIO模型的selector 就像一个大总管，负责监听各种IO事件，然后转交给后端线程去处理 。<br><strong>NIO相对于BIO非阻塞的体现就在，BIO的后端线程需要阻塞等待客户端写数据(比如read方法)，如果客户端不写数据线程就要阻塞， NIO把等待客户端操作的事情交给了大总管 selector，selector 负责轮询所有已注册的客户端，发现有事件发生了才转交给后端线程处 理，后端线程不需要做任何阻塞等待，直接处理客户端事件的数据即可，处理完马上结束，或返回线程池供其他客户端事件继续使用。还 有就是 channel 的读写是非阻塞的</strong>。</p>
<p> Redis就是典型的NIO线程模型，selector收集所有连接的事件并且转交给后端线程，线程连续执行所有事件命令并将结果写回客户端*</p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 风信子</span></span><br><span class="line"><span class="comment"> * NIO 服务端实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个本地端口监听的服务socket通道,并设置为非阻塞方式</span></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// selector是非阻塞模式,必须设置为非阻塞才能在selector上注册,否则会报错.</span></span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 创建一个selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel 注册到selector上面,并设置对客户端的accept感兴趣</span></span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"等待事件发生.."</span>);</span><br><span class="line">            <span class="comment">// 轮询监听channel里面的key,select 是阻塞的 accept也是阻塞的</span></span><br><span class="line">            selector.select();</span><br><span class="line">            System.out.println(<span class="string">"有事件发生了.."</span>);</span><br><span class="line">            <span class="comment">// 轮询监听到客户端请求</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey key = it.next();</span><br><span class="line">                <span class="comment">// 删除本次处理的key ,防止下次select 重复处理</span></span><br><span class="line">                it.remove();</span><br><span class="line">                handler(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(<span class="string">"有客户端连接事件发生了.."</span>);</span><br><span class="line">            ServerSocketChannel ssc =(ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="comment">// NIO非阻塞体现:此处accept方法会阻塞 但它是连接事件所有很快就会执行完，不会阻塞</span></span><br><span class="line">            <span class="comment">// 处理完连接请求不会继续等待客户端的数据发送</span></span><br><span class="line">            SocketChannel sc= ssc.accept();</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 通过Selector 监听Channel 时对读事件感兴趣</span></span><br><span class="line">            sc.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">            System.out.println(<span class="string">"有客户端可读数据事件发生.."</span>);</span><br><span class="line">            SocketChannel sc =(SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// NIO非阻塞体现:首先read请求不会阻塞,其次这种事件响应模型,当调用到read方法是肯定是客户端发生了发送数据的事件</span></span><br><span class="line">            <span class="keyword">int</span> len = sc.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收到了客户端的消息:"</span>+<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferWrite = ByteBuffer.wrap(<span class="string">"hello client"</span>.getBytes());</span><br><span class="line">            sc.write(bufferWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ|SelectionKey.OP_WRITE);</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 风信子</span></span><br><span class="line"><span class="comment"> * NIO 客户端实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        NioClient nioClient = <span class="keyword">new</span> NioClient();</span><br><span class="line">        nioClient.initClient(<span class="string">"127.0.0.1"</span>,<span class="number">9000</span>);</span><br><span class="line">        nioClient.connection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">(String ip,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个socket 通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置通道为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 获取一个通道管理器</span></span><br><span class="line">        <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">        <span class="comment">// 客户端连接服务器,其实方法执行并没实现连接，需要在listen()方法中</span></span><br><span class="line">        <span class="comment">// 调用channel.finishConnection才能完成连接</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(ip,port));</span><br><span class="line">        <span class="comment">// 将管道管理器和通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件</span></span><br><span class="line">        socketChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connection</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 轮询访问selector</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 选择一组可以进行I/O操作的事件,放在selector中,客户端该方法不会阻塞</span></span><br><span class="line">            <span class="comment">// 这里和服务端的方法不一样,查看api注释可以知道，服务端当至少一个通道被选中时</span></span><br><span class="line">            <span class="comment">// selector的wakeup方法被调用，方法返回，而对于客户端来说，通道是一直被选中的</span></span><br><span class="line">            <span class="keyword">this</span>.selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey key = it.next();</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="comment">// 连接事件发生</span></span><br><span class="line">                <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                    SocketChannel socketChannel =(SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 如果正在连接则完成连接</span></span><br><span class="line">                    <span class="keyword">if</span>(socketChannel.isConnectionPending())&#123;</span><br><span class="line">                        socketChannel.finishConnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置成非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 向服务器发送信息</span></span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.wrap(<span class="string">"hello server"</span>.getBytes());</span><br><span class="line">                    socketChannel.write(byteBuffer);</span><br><span class="line">                    <span class="comment">// 连接成功之后注册读取服务器信息事件</span></span><br><span class="line">                    socketChannel.register(<span class="keyword">this</span>.selector,SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    read(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> len = channel.read(byteBuffer);</span><br><span class="line">        <span class="keyword">if</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"接收到服务端信息:"</span>+<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AIO-NIO-2-0"><a href="#AIO-NIO-2-0" class="headerlink" title="AIO(NIO 2.0)"></a>AIO(NIO 2.0)</h2><p>异步非阻塞模型，由操作系统完成后回调通知服务端程序启用线程去处理，一般使用于连接数较多且连接时间长的应用。</p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，jdk7开始支持。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 风信子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverChannel =</span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>)) ;</span><br><span class="line">        <span class="comment">// 异步点: 通过钩子函数处理连接请求</span></span><br><span class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 此处接收客户端请求,不写这行代码客户端连接不上服务器</span></span><br><span class="line">                    serverChannel.accept(attachment,<span class="keyword">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer byteBuffer  = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 异步点: 通过钩子函数处理数据接收操作</span></span><br><span class="line">                    socketChannel.read(byteBuffer, byteBuffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            System.out.println(<span class="string">"接收到客户端消息:"</span>+<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">"hello client"</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 风信子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel socketChannel = AsynchronousSocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>)).get();</span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">"HelloServer"</span>.getBytes()));</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        Integer len = socketChannel.read(buffer).get();</span><br><span class="line">        <span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"客户端收到信息："</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BIO、NIO、AIO-对比"><a href="#BIO、NIO、AIO-对比" class="headerlink" title="BIO、NIO、AIO 对比"></a>BIO、NIO、AIO 对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">BIO</th>
<th align="center">NIO</th>
<th align="center">AIO</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IO模型</td>
<td align="center">同步阻塞</td>
<td align="center">同步非阻塞（多路复用）</td>
<td align="center">异步非阻塞</td>
</tr>
<tr>
<td align="center">编程难度</td>
<td align="center">简单</td>
<td align="center">复杂</td>
<td align="center">复杂</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">吞吐量</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h3 id="网络段子"><a href="#网络段子" class="headerlink" title="网络段子"></a>网络段子</h3><p>老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 </p>
<p> 老张把水壶放到火上，立等水开。（<strong>同步阻塞</strong>） 老张觉得自己有点傻<br> 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（<strong>同步非阻塞</strong>） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀<del>~</del>的噪音。<br> 老张把响水壶放到火上，立等水开。（<strong>异步阻塞</strong>） 老张觉得这样傻等意义不大<br>  老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（<strong>异步非阻塞</strong>） 老张觉得自己聪明了。</p>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；<br>响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。<br>这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。<br>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>JAVAIO模型</category>
      </categories>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList源码解析</title>
    <url>/java/container/CopyOnWriteArrayList/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><em>特性基本与ArrayList一致，底层也是数组结构</em></p>
<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;<span class="comment">//序列化版本号</span></span><br><span class="line"><span class="comment">//全局锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//存储数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);<span class="comment">//创建一个大小为0的Object数组作为array初始值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个list，其内部元素是toCopyIn的的副本</span></span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[]<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将传入参数集合中的元素复制到本list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">elements</span> </span>= ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray可能不是Object[]（比如：继承ArrayList</span></span><br><span class="line">        <span class="comment">// 重写toArray方法返回String[]</span></span><br><span class="line">        <span class="comment">//只有ArrayList的toArray方法实现是Arrays.copyOf</span></span><br><span class="line">        <span class="comment">// 因此在jdk8中，此处改为了ArrayList.class）</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elements</span> </span>= Arrays.copyOf(elements, elements.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="默认插入"><a href="#默认插入" class="headerlink" title="默认插入"></a>默认插入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//先加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制到新数组中，长度+1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//在新数组中添加元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//将新数组设置给array</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定位置插入"><a href="#指定位置插入" class="headerlink" title="指定位置插入"></a>指定位置插入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 检查是否越界, 可以等于len</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果插入的位置是最后一位</span></span><br><span class="line">            <span class="comment">// 那么拷贝一个n+1的数组, 其前n个元素与旧数组一致</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果插入的位置不是最后一位</span></span><br><span class="line">            <span class="comment">// 那么新建一个n+1的数组</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 拷贝旧数组前index的元素到新数组中</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 将index及其之后的元素往后挪一位拷贝到新数组中</span></span><br><span class="line">            <span class="comment">// 这样正好index位置是空出来的</span></span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将元素放置在index处</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="addIfAbsent"><a href="#addIfAbsent" class="headerlink" title="addIfAbsent"></a>addIfAbsent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加一个不存在于集合中的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取元素数组</span></span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">//已存在返回false，否则添加</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新获取旧数组</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="comment">// 如果快照与刚获取的数组不一致，说明有修改</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">// 重新检查元素是否在刚获取的数组里，减少indexOf的对比次数</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="comment">//判断是否有线程指定下标添加了元素</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拷贝一份n+1的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将元素放在最后一位</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>这个方法是线程不安全的，因为这个分成了两步，分别是获取数组和获取元素，而且中间过程没有加锁。假设当前线程在获取数组（执行getArray()）后，其他线程修改了这个CopyOnWriteArrayList，那么它里面的元素就会改变，但此时当前线程返回的仍然是旧的数组，所以返回的元素就不是最新的了，这就是写时复制策略产生的弱一致性问题。</em></strong></p>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 先获取要修改的旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 值确实需要修改</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 将array复制到新数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);     </span><br><span class="line">            <span class="comment">// 修改元素       </span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置array为新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 虽然值不需要改，但要保证volatile语义，需重新设置array</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//获取要删除的元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)<span class="comment">//删除的是最后一个元素</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将元素分两次复制到新数组中</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//拷贝index前面的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">//拷贝index后面的元素</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个COWIterator对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//数组array快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">//遍历时的数组下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        <span class="comment">//保存了当前list的内容</span></span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>如果在返回迭代器后没有对里面的数组array进行修改，则这两个变量指向的确实是同一个数组；但是若修改了，则根据前面所讲，它是会新建一个数组，然后将修改后的数组复制到新建的数组，而老的数组就会被“丢弃”，所以如果修改了数组，则此时snapshot指向的还是原来的数组，而array变量已经指向了新的修改后的数组了。这也就说明获取迭代器后，使用迭代器元素时，其他线程对该list的增删改不可见，因为他们操作的是两个不同的数组，这就是弱一致性。</em></strong></p>
<p><strong><em>CopyOnWriteArrayList使用写时复制策略保证list的一致性，而获取–修改–写入三个步骤不是原子性，所以需要一个独占锁保证修改数据时只有一个线程能够进行。另外，CopyOnWriteArrayList提供了弱一致性的迭代器，从而保证在获取迭代器后，其他线程对list的修改是不可见的，迭代器遍历的数组是一个快照。</em></strong></p>
<h2 id="使用场景及优点"><a href="#使用场景及优点" class="headerlink" title="使用场景及优点"></a>使用场景及优点</h2><p><strong><em>并发容器用于读多写少的并发场景。比如白名单，黑名单等场景。</em></strong></p>
<p><strong><em>读操作可能会远远多于写操作的场景。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。</em></strong></p>
<p><strong><em>CopyOnWriteArrayList 的思想比读写锁的思想更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。读写分离</em></strong> </p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong><em>内存占用，弱一致性</em></strong> </p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><em>为什么CopyOnWriteArrayList没有size属性?</em></p>
]]></content>
      <categories>
        <category>java</category>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>redis单机安装</title>
    <url>/middleware/redis/install/</url>
    <content><![CDATA[<p><a href="https://redis.io/" target="_blank" rel="noopener">redis 官网</a></p>
<ol>
<li><p>下载: wget <a href="http://download.redis.io/releases/redis-5.0.3.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.3.tar.gz</a><br><img src="https://img-blog.csdnimg.cn/20210129134941616.png" alt="我的下载目录为 /usr/local "></p>
</li>
<li><p>解压：tar xzf redis-5.0.3.tar.gz<img src="https://img-blog.csdnimg.cn/20210129144102539.png" alt="在这里插入图片描述"></p>
</li>
<li><p>进入redis 目录: cd redis-5.0.3<img src="https://img-blog.csdnimg.cn/20210129135518839.png" alt="在这里插入图片描述"></p>
</li>
<li><p>编译与安装: make (redis是由C语言编写的，它的运行需要C环境，所以编译前需安装 gcc：yum install gcc-c++) </p>
</li>
<li><p>启动并指定配置文件:src/redis-server redis.conf (后台启动将配置文件中deamonize 改为yes)<br><img src="https://img-blog.csdnimg.cn/20210129135744712.png" alt="修改配置文件"><br><img src="https://img-blog.csdnimg.cn/20210129140033489.png" alt="设置后台启动，保存退出"><br><img src="https://img-blog.csdnimg.cn/2021012914020558.png" alt="启动redis"></p>
</li>
<li><p>验证是否启动成功: ps -ef|grep redis<br><img src="https://img-blog.csdnimg.cn/20210129140404579.png" alt="在这里插入图片描述"></p>
</li>
<li><p>连接客户端: src/redis-cli  -h  {ip} -p {port} （ip默认localhost ip默认6379）<br><img src="https://img-blog.csdnimg.cn/20210129140542779.png" alt="在这里插入图片描述"></p>
</li>
<li><p>单机安装完成</p>
</li>
</ol>
]]></content>
      <categories>
        <category>middleware</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码解析</title>
    <url>/java/container/LinkedList/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h3 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h3><p>   <em>继承于AbstractSequentialList,本质上面与继承AbstractList没有什么区别,AbstractSequentialList完善了AbstractList中没有实现的方法。</em></p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>   <em>可序列化。成员变量 Node 使用 transient 修饰，通过重写read/writeObject 方法实现序列化。</em></p>
<h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>   <em>重写clone()方法，通过创建新的LinkedList对象，遍历拷贝数据进行对象拷贝。</em></p>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>   <em>实现了Collection大家庭中的队列接口,说明他拥有作为双端队列的功能。</em></p>
<p><strong><em>LinkedList与ArrayList最大的区别就是LinkedList中实现了Collection中的QueueDeque接口拥有作为双端队列的功能!</em></strong></p>
<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Node的数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本节点的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E item;<span class="comment">//存储元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点（后继）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一个节点(前驱)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>LinkedList 在1.6 版本以及之前，只通过一个 header 头指针保存队列头和尾。这种操作可以说很有深度，但是从代码阅读性来说，却加深了阅读代码的难度。因此在后续的JDK 更新中，将头节点和尾节点 区分开了。节点类也更名为 Node。</em></strong></p>
<p><strong><em>为什么Node这个类是静态的？答案是：这跟内存泄露有关，Node类是在LinkedList类中的，也就是一个内部类，若不使用static修饰，那么Node就是一个普通的内部类，在java中，一个普通内部类在实例化之后，默认会持有外部类的引用，这就有可能造成内存泄露（内部类与外部类生命周期不一致时）。但使用static修饰过的内部类（称为静态内部类），就不会有这种问题</em></strong></p>
<p><strong><em>非静态内部类会自动生成一个构造器依赖于外部类:也是内部类可以访问外部类的实例变量的原因,静态内部类不会生成,访问不了外部类的实例变量,只能访问类变量。通过字节码可以得到验证!</em></strong></p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">//操作次数只会记录一次设置前驱后继</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认尾部添加</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标节点创建后寻找前驱节点,前驱节点存在就修改前驱节点的后继,指向目标节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取这个list对象内部的Node类型成员last，即末位节点，以该节点作为新插入元素的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//把新节点作为该list对象的最后一个节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//处理原先的末位节点，如果这个list本来就是一个空的链表</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//把新节点作为首节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果链表内部已经有元素，把原来的末位节点的后继指向新节点，完成链表修改</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//修改当前list的size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//并记录该list对象被执行修改的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标的合法性</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//插入位置是末位，那还是上面末位添加的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分查找 index离哪端更近 就从哪端开始找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            <span class="comment">//找到index位置的元素</span></span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指位添加方法核心逻辑  操作新节点</span></span><br><span class="line"><span class="comment"> * 紧接修改原有节点的前驱属性，最后再修改前驱节点的后继属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原位置节点的前驱pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//创建新节点,设置新节点其前驱为原位置节点的前驱pred，其后继为原位置节点succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//将新节点设置到原位置节点的前驱</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//前驱如果为空，空链表，则新节点设置为first</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//将新节点设置到前驱节点的后继</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">//修改当前list的size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//记录该list对象被执行修改的次数。</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//将集合转化为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">//获取插入节点的前节点（prev）和尾节点（next）</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将集合中的数据编织成链表</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 Collection 的链表插入 LinkedList 中。</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><h3 id="AbstractSequentialList-gt-remove"><a href="#AbstractSequentialList-gt-remove" class="headerlink" title="AbstractSequentialList-&gt;remove"></a>AbstractSequentialList-&gt;remove</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//node(index)找到index位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * remove(Object o)这个删除元素的方法的形参o是数据本身</span></span><br><span class="line"><span class="comment"> * 而不是LinkedList集合中的元素（节点）</span></span><br><span class="line"><span class="comment"> * 所以需要先通过节点遍历的方式，找到o数据对应的元素</span></span><br><span class="line"><span class="comment"> * 然后再调用unlink(Node x)方法将其删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//x的数据域element</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">//x的下一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">//x的上一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="comment">//如果x的上一个结点是空结点的话，那么说明x是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将x的前后节点相连双向链表</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//x的属性置空</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果x的下一个结点是空结点的话，那么说明x是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将x的前后节点相连   双向链表</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向null  方便GC回收</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Deque-gt-remove"><a href="#Deque-gt-remove" class="headerlink" title="Deque-&gt;remove"></a>Deque-&gt;remove</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">//获取到头结点的下一个结点      </span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//GC</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//头指针指向的是头结点的下一个结点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双端链表-队列Queue"><a href="#双端链表-队列Queue" class="headerlink" title="双端链表(队列Queue)"></a>双端链表(队列Queue)</h2><p><strong><em>java中队列的实现就是LinkedList： 我们之所以说LinkedList 为双端链表，是因为他实现了Deque 接口；我们知道，队列是先进先出的，添加元素只能从队尾添加，删除元素只能从队头删除，Queue中的方法就体现了这种特性。 支持队列的一些操作，我们来看一下有哪些方法实现：</em></strong></p>
<ul>
<li>pop() 是栈结构的实现类的方法，返回的是栈顶元素，并且将栈顶元素删除</li>
<li>poll() 是队列的数据结构，获取对头元素并且删除队头元素</li>
<li>push() 是栈结构的实现类的方法，把元素压入到栈中</li>
<li>peek() 获取队头元素 ，但是不删除队列的头元素</li>
<li>offer() 添加队尾元素</li>
</ul>
<h3 id="队列增加"><a href="#队列增加" class="headerlink" title="队列增加"></a>队列增加</h3><p><em>offer()添加队尾元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列删除"><a href="#队列删除" class="headerlink" title="队列删除"></a>队列删除</h3><p><em>poll()是队列的数据结构，获取对头元素并且删除队头元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列查询"><a href="#队列查询" class="headerlink" title="队列查询"></a>队列查询</h3><p><em>peek()获取队头元素 ，但是不删除队列的头元素</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的增"><a href="#栈的增" class="headerlink" title="栈的增"></a>栈的增</h3><p><em>push（）是栈结构的实现类的方法，把元素压入到栈中<br> push（） 方法的底层实现，其实就是调用了 addFirst（Object o）</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈的删"><a href="#栈的删" class="headerlink" title="栈的删"></a>栈的删</h3><p><em>pop（）是栈结构的实现类的方法，返回的是栈顶元素，并且将栈顶元素删除</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>zookeeper介绍及基本使用</title>
    <url>/middleware/zookeeper/index/</url>
    <content><![CDATA[<h1 id="zookeeper简介"><a href="#zookeeper简介" class="headerlink" title="zookeeper简介"></a>zookeeper简介</h1><h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><p> 从单体项目到分布式项目转变之后，会产生多个服务节点之间的协同问题。如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每天的定时任务有哪个节点执行</span><br><span class="line">RPC调用时的服务发现</span><br><span class="line">如何保证并发请求的幂等性</span><br><span class="line">			...</span><br></pre></td></tr></table></figure>

<p><strong>这些问题可以统一归纳为多节点协调问题，如果靠节点自身进行协调这是非常不可靠的，性能也不可取。必须由一个独立的服务去完成协调工作，它必须可靠且保证性能。</strong></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Zookeeper 是用于分布式应用程序的协调服务。他有一组简单的API，基于这组API可以进行同步节点状态、配置等信息、服务发现等。它由JAVA编写，支持JAVA和C两种语言的客户端。</p>
<h2 id="znode节点"><a href="#znode节点" class="headerlink" title="znode节点"></a>znode节点</h2><p>zookeeper中数据的基本单元叫节点,节点下面可以包含子节点，最后以树的方式展现，每个节点拥有唯一的路径。客户端基于path上传节点数据，zookeeper收到后会实时的通知对该路径监听的客户端。<br><img src="https://img-blog.csdnimg.cn/20210226134646611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="部署与常规配置"><a href="#部署与常规配置" class="headerlink" title="部署与常规配置"></a>部署与常规配置</h1><h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><ol>
<li><p>wget <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/current/apache-" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/current/apache-</a> zookeeper-3.5.5-bin.tar.gz</p>
</li>
<li><p>tar -zxvf apache-zookeeper-3.5.5-bin.tar.gz</p>
</li>
<li><p>拷贝默认配置</p>
<blockquote>
<p>cd {zookeeper_home}/conf<br> cp zoo_sample.cfg zoo.cfg</p>
</blockquote>
</li>
<li><p>启动   </p>
<blockquote>
<p>{zookeeper_home}/bin/zkServer.sh</p>
</blockquote>
</li>
</ol>
<h2 id="常规配置文件说明"><a href="#常规配置文件说明" class="headerlink" title="常规配置文件说明"></a>常规配置文件说明</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # zookeeper时间配置中的基本单位 (毫秒)</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"></span><br><span class="line">#允许follower初始化连接到leader最大时长，它表示tickTime时间倍数 实际时间为:initLimit*tickTime</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"></span><br><span class="line">#允许follower与leader数据同步最大时长,它表示tickTime时间倍数 </span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"></span><br><span class="line">#zookeper 数据存储目录  </span><br><span class="line">dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper</span><br><span class="line"></span><br><span class="line">#对客户端提供的端口号</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"></span><br><span class="line">#单个客户端与zookeeper最大并发连接数</span><br><span class="line">maxClientCnxns&#x3D;60</span><br><span class="line"></span><br><span class="line">#保存的数据快照数量，之外的将会被清除</span><br><span class="line">autopurge.snapRetainCount&#x3D;3</span><br><span class="line"></span><br><span class="line">#自动触发清除任务时间间隔，小时为单位。默认为0，表示不自动清除。</span><br><span class="line">autopurge.purgeInterval&#x3D;1</span><br></pre></td></tr></table></figure>
<h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><h3 id="基本命令列表"><a href="#基本命令列表" class="headerlink" title="基本命令列表"></a>基本命令列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关闭当前会话</span><br><span class="line">close  </span><br><span class="line"></span><br><span class="line">#重新连接指定Zookeeper服务</span><br><span class="line">connect host:port </span><br><span class="line"></span><br><span class="line">#创建节点</span><br><span class="line">create [-s] [-e] [-c] [-t ttl] path [data] [acl]</span><br><span class="line"></span><br><span class="line">#删除节点，(不能存在子节点）</span><br><span class="line">delete [-v version] path</span><br><span class="line"></span><br><span class="line">#删除路径及所有子节点</span><br><span class="line">deleteall path</span><br><span class="line"></span><br><span class="line"> #设置节点限额 -n 子节点数 -b 字节数</span><br><span class="line">setquota -n|-b val path</span><br><span class="line"></span><br><span class="line">#查看节点限额</span><br><span class="line">listquota path</span><br><span class="line"></span><br><span class="line">#删除节点限额</span><br><span class="line">delquota [-n|-b] path</span><br><span class="line"></span><br><span class="line">#查看节点数据 -s 包含节点状态 -w 添加监听</span><br><span class="line">get [-s] [-w] path</span><br><span class="line"></span><br><span class="line">#列出子节点 -s状态 -R 递归查看所有子节点 -w 添加监听 </span><br><span class="line">getAcl [-s] path</span><br><span class="line">ls [-s] [-w] [-R] path</span><br><span class="line"></span><br><span class="line">#是否打印监听事件</span><br><span class="line">printwatches on|off</span><br><span class="line"></span><br><span class="line">#退出客户端</span><br><span class="line">quit </span><br><span class="line"></span><br><span class="line">#查看执行的历史记录</span><br><span class="line">history </span><br><span class="line"></span><br><span class="line">#重复 执行命令，history 中命令编号确定</span><br><span class="line">redo cmdno</span><br><span class="line"></span><br><span class="line">#删除指定监听</span><br><span class="line">removewatches path [-c|-d|-a] [-l]</span><br><span class="line"></span><br><span class="line">#设置值</span><br><span class="line">set [-s] [-v version] path data</span><br><span class="line"></span><br><span class="line">#为节点设置ACL权限</span><br><span class="line">setAcl [-s] [-v version] [-R] path acl</span><br><span class="line"></span><br><span class="line">#查看节点状态 -w 添加监听</span><br><span class="line">stat [-w] path</span><br><span class="line"></span><br><span class="line">#强制同步节点</span><br><span class="line">sync path</span><br></pre></td></tr></table></figure>

<h3 id="node数据的增删改查"><a href="#node数据的增删改查" class="headerlink" title="node数据的增删改查"></a>node数据的增删改查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出子节点 </span><br><span class="line">ls &#x2F;</span><br><span class="line"></span><br><span class="line">#创建节点</span><br><span class="line">create &#x2F;fengxinzi &quot;fengxinzi is good man&quot;</span><br><span class="line"></span><br><span class="line"># 查看节点</span><br><span class="line">get &#x2F;fengxinzi</span><br><span class="line"></span><br><span class="line"># 创建子节点 </span><br><span class="line">create &#x2F;fengxinzi&#x2F;sex &quot;man&quot;</span><br><span class="line"></span><br><span class="line"># 删除节点</span><br><span class="line">delete &#x2F;fengxinzi&#x2F;sex</span><br><span class="line"></span><br><span class="line"># 删除所有节点 包括子节点</span><br><span class="line">deleteall &#x2F;fengxinzi</span><br></pre></td></tr></table></figure>
<h1 id="zookeeper-节点介绍"><a href="#zookeeper-节点介绍" class="headerlink" title="zookeeper 节点介绍"></a>zookeeper 节点介绍</h1><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PERSISTENT</td>
<td align="center">持久节点</td>
</tr>
<tr>
<td align="center">PERSISTENT_SEQUENTIAL</td>
<td align="center">持久序号节点</td>
</tr>
<tr>
<td align="center">EPHEMERAL</td>
<td align="center">临时节点（不能拥有子节点）</td>
</tr>
<tr>
<td align="center">EPHEMERAL_SEQUENTIAL</td>
<td align="center">临时序号节点(不能拥有子节点)</td>
</tr>
<tr>
<td align="center">CONTAINER</td>
<td align="center">容器节点</td>
</tr>
</tbody></table>
<p>1.持久节点</p>
<p>会进行持久化保存的节点，也是默认创建的节点类型</p>
<blockquote>
<p>#创建持久节点<br> create /user</p>
</blockquote>
<p>2.持久序号节点</p>
<p>创建此类型节点时zookeeper会在路径上加上序号作为后缀。适合用于分布式锁、分布式选举等场景。创建时添加 -s 参数即可。</p>
<blockquote>
<p>#创建序号节点<br>create -s /user<br>#返回创建的实际路径<br>Created /user0000000001<br>create -s /user<br>#返回创建的实际路径2<br>Created /user0000000002</p>
</blockquote>
<p>3.临时节点</p>
<p>临时节点会在客户端会话断开后自动删除。适用于心跳，服务发现等场景。创建时添加参数-e 即可。</p>
<blockquote>
<p>#创建临时节点,断开会话 在连接将会自动删除<br>create -e /temp</p>
</blockquote>
<p>4.临时序号节点</p>
<p>与持久序号节点类似，不同之处在于EPHEMERAL_SEQUENTIAL是临时的会在会话断开后删除。创建时添加 -e -s </p>
<blockquote>
<p>#创建临时序号节点<br>create -e -s /temp/seq</p>
</blockquote>
<p>5.容器节点</p>
<p>如果Container节点下面没有子节点，则Container节点 在未来会被Zookeeper自动清除,定时任务默认60s 检查一次。</p>
<p>6.TTL节点</p>
<p>默认禁用，只能通过系统配置zookeeper.extendedTypesEnabled=true开启，不稳定。</p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>查看节点属性命令:stat /fengxinzi<br>节点属性说明如下:</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cZxid = 0x385</td>
<td align="center">创建节点的事物ID</td>
</tr>
<tr>
<td align="center">ctime = Tue Sep 24 17:26:28 CST 2020</td>
<td align="center">#创建时间</td>
</tr>
<tr>
<td align="center">mZxid = 0x385</td>
<td align="center">修改节点的事物ID</td>
</tr>
<tr>
<td align="center">mtime = Tue Sep 24 17:26:28 CST 2020</td>
<td align="center">最后修改时间</td>
</tr>
<tr>
<td align="center">pZxid = 0x385</td>
<td align="center">mtime = Tue Sep 24 17:26:28 CST 2019</td>
</tr>
<tr>
<td align="center">cversion = 0</td>
<td align="center">znode的子节点进行的更改次数</td>
</tr>
<tr>
<td align="center">dataVersion = 0</td>
<td align="center">数据版本，变更次数</td>
</tr>
<tr>
<td align="center">aclVersion = 0</td>
<td align="center">dataVersion = 0</td>
</tr>
<tr>
<td align="center">ephemeralOwner = 0x0</td>
<td align="center">临时节点所属会话ID</td>
</tr>
<tr>
<td align="center">dataLength = 17</td>
<td align="center">数据长度</td>
</tr>
<tr>
<td align="center">numChildren = 0</td>
<td align="center">子节点数</td>
</tr>
</tbody></table>
<h3 id="节点监听"><a href="#节点监听" class="headerlink" title="节点监听"></a>节点监听</h3><p>客户添加 -w 参数可实时监听节点与子节点的变化，并且实时收到通知。非常适用保障分布式情况下的数据一致性。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ls -w path</td>
<td align="center">监听子节点的变化（增，删</td>
</tr>
<tr>
<td align="center">get -w path</td>
<td align="center">监听节点数据的变化</td>
</tr>
<tr>
<td align="center">stat -w path</td>
<td align="center">监听节点属性的变化</td>
</tr>
<tr>
<td align="center">printwatches on/off</td>
<td align="center">触发监听后，是否打印监听事件(默认on)</td>
</tr>
</tbody></table>
<h3 id="acl权限设置"><a href="#acl权限设置" class="headerlink" title="acl权限设置"></a>acl权限设置</h3><p>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。ZooKeeper使用ACL来控制对其znode的防问。基于scheme:Id:permission的方式进行权限控制。scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</p>
<h4 id="scheme-认证模型"><a href="#scheme-认证模型" class="headerlink" title="scheme 认证模型"></a>scheme 认证模型</h4><table>
<thead>
<tr>
<th align="center">方案</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">world</td>
<td align="center">开放模式，world表示全世界都可以访问（这是默认设置）</td>
</tr>
<tr>
<td align="center">ip</td>
<td align="center">ip模式，限定客户端IP防问</td>
</tr>
<tr>
<td align="center">auth</td>
<td align="center">用户密码认证模式，只有在会话中添加了认证才可以防问</td>
</tr>
<tr>
<td align="center">digest</td>
<td align="center">与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td>
</tr>
</tbody></table>
<h4 id="permission权限位"><a href="#permission权限位" class="headerlink" title="permission权限位"></a>permission权限位</h4><table>
<thead>
<tr>
<th align="center">权限位</th>
<th align="center">权限</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c</td>
<td align="center">CREATE</td>
<td align="center">可以创建子节点</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">DELETE</td>
<td align="center">可以删除子节点（仅下一级节点）</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">READ</td>
<td align="center">可以读取节点数据及显示子节点列表</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">WRITE</td>
<td align="center">可以设置节点数据</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">ADMIN</td>
<td align="center">可以设置节点访问控制列表权限</td>
</tr>
<tr>
<td align="center">acl 相关命令：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">命令</td>
<td align="center">使用方式</td>
<td align="center">描述</td>
</tr>
<tr>
<td align="center">:——–:</td>
<td align="center">:————-:</td>
<td align="center">:————-:</td>
</tr>
<tr>
<td align="center">getAcl</td>
<td align="center">getAcl ${path}</td>
<td align="center">读取ACL权限</td>
</tr>
<tr>
<td align="center">setAcl</td>
<td align="center">setAcl ${path} ${acl}</td>
<td align="center">设置ACL权限</td>
</tr>
<tr>
<td align="center">addauth</td>
<td align="center">addauth ${scheme} ${auth}</td>
<td align="center">添加认证用户</td>
</tr>
</tbody></table>
<h4 id="权限示例"><a href="#权限示例" class="headerlink" title="权限示例"></a>权限示例</h4><h5 id="world权限示例"><a href="#world权限示例" class="headerlink" title="world权限示例"></a>world权限示例</h5><p><strong>语法： setAcl ${path} world:anyone:&lt;权限位&gt; （world模式中anyone是唯一的值,表示所有人)</strong></p>
<p>1.查看默认节点权限</p>
<blockquote>
<p>#创建一个节点<br>create -e /testAcl<br>#查看节点权限<br>getAcl /testAcl<br>#返回的默认权限表示 ，所有人拥有所有权限。<br>‘world,’anyone: cdrwa</p>
</blockquote>
<p>2.修改默认权限为 读写</p>
<blockquote>
<p>#设置为rw权限<br>setAcl /testAcl world:anyone:rw<br>#可以正常读<br>get /testAcl<br>#无法正常创建子节点<br>create -e /testAcl/t “hi”<br>#上面命令返回没有权限的异常<br>Authentication is not valid : /testAcl/t</p>
</blockquote>
<h5 id="IP权限示例"><a href="#IP权限示例" class="headerlink" title="IP权限示例"></a>IP权限示例</h5><blockquote>
<p> setAcl path ip:&lt;ip地址|地址段&gt;:&lt;权限位&gt;</p>
</blockquote>
<h5 id="auth模式示例"><a href="#auth模式示例" class="headerlink" title="auth模式示例"></a>auth模式示例</h5><blockquote>
<p>setAcl  path auth:&lt;用户名&gt;:&lt;密码&gt;:&lt;权限位&gt;<br>addauth digest &lt;用户名&gt;:&lt;密码&gt;</p>
</blockquote>
<h5 id="digest-权限示例"><a href="#digest-权限示例" class="headerlink" title="digest 权限示例"></a>digest 权限示例</h5><blockquote>
<p>setAcl ${path} digest :&lt;用户名&gt;:&lt;密钥&gt;:&lt;权限位&gt;<br>addauth digest &lt;用户名&gt;:&lt;密码&gt;</p>
</blockquote>
<p>注意点1：密钥 通过sha1与base64组合加密码生成，可通过以下命令生成</p>
<blockquote>
<p>echo -n &lt;用户名&gt;:&lt;密码&gt; | openssl dgst -binary -sha1 | openssl base64</p>
</blockquote>
<p>注意点2：为节点设置digest 权限后，访问前必须执行addauth，当前会话才可以防问</p>
]]></content>
      <categories>
        <category>middleware</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群</title>
    <url>/middleware/zookeeper/cluster/</url>
    <content><![CDATA[<h1 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h1><p>zookeeper集群的目的是为了保证系统的性能承载更多的客户端连接设专门提供的机制。通过集群可以实现以下功能：</p>
<ol>
<li>读写分离：提高承载，为更多的客户端提供连接，并保障性能。</li>
<li>主从自动切换：提高服务容错性，部分节点故障不会影响整个服务集群。</li>
</ol>
<p><strong>运行机制说明:集群至少需要三台服务器，并且强烈建议使用奇数个服务器。因为zookeeper 通过判断大多数节点的存活来判断整个服务是否可用。比如3个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个也表示其并不是大部分存活，因此也会挂掉</strong></p>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><p>server.&lt;节点ID&gt;=<ip>:&lt;数据同步端口&gt;:&lt;选举端口&gt;</ip></p>
<ul>
<li><strong>节点ID</strong>：服务id手动指定1至125之间的数字，并写到对应服务节点的 {dataDir}/myid 文件中。</li>
<li><strong>IP地址</strong>： 节点的远程IP地址，可以相同。但生产环境就不能这么做了，因为在同一台机器就无法达到容错的目的。所以这种称作为伪集群。</li>
<li><strong>数据同步端口</strong>：主从同时数据复制端口，（做伪集群时端口号不能重复）。</li>
<li><strong>远举端口</strong>：主从节点选举端口，（做伪集群时端口号不能重复。)<h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 属性在第一篇zookeeper文章中有介绍</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper/</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">#以下为集群配置，必须配置在所有节点的zoo.cfg文件中</span><br><span class="line">server.1=zoo1:2888:3888</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3></li>
</ul>
<ol>
<li><p>分别创建3个data目录用于存储各节点数据:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">mkdir data/1</span><br><span class="line">mkdir data/2</span><br><span class="line">mkdir data/3</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210303173338360.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210303173458505.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>编写myid文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; data&#x2F;1&#x2F;myid</span><br><span class="line">echo 3 &gt; data&#x2F;3&#x2F;myid</span><br><span class="line">echo 2 &gt; data&#x2F;2&#x2F;myid</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>编写配置文件</p>
</li>
</ol>
<p>conf/zoo1.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">dataDir&#x3D;data&#x2F;1</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line">#集群配置</span><br><span class="line">server.1&#x3D;127.0.0.1:2887:3887</span><br><span class="line">server.2&#x3D;127.0.0.1:2888:3888</span><br><span class="line">server.3&#x3D;127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure>

<p>conf/zoo2.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">dataDir&#x3D;data&#x2F;2</span><br><span class="line">clientPort&#x3D;2182</span><br><span class="line">#集群配置</span><br><span class="line">server.1&#x3D;127.0.0.1:2887:3887</span><br><span class="line">server.2&#x3D;127.0.0.1:2888:3888</span><br><span class="line">server.3&#x3D;127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure>
<p>conf/zoo3.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">dataDir&#x3D;data&#x2F;3</span><br><span class="line">clientPort&#x3D;2183</span><br><span class="line">#集群配置</span><br><span class="line">server.1&#x3D;127.0.0.1:2887:3887</span><br><span class="line">server.2&#x3D;127.0.0.1:2888:3888</span><br><span class="line">server.3&#x3D;127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210303174202180.png" alt="在这里插入图片描述"></p>
<ol start="4">
<li>分别启动<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh start conf/zoo1.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zoo2.cfg</span><br><span class="line">./bin/zkServer.sh start conf/zoo3.cfg</span><br></pre></td></tr></table></figure></li>
<li>查看状态<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh status conf/zoo1.cfg</span><br><span class="line">结果:Mode: follower</span><br><span class="line">./bin/zkServer.sh status conf/zoo2.cfg</span><br><span class="line">结果:Mode: leader</span><br><span class="line">./bin/zkServer.sh status conf/zoo3.cfg</span><br><span class="line">结果:Mode: follower</span><br></pre></td></tr></table></figure>
<h2 id="检查集群复制情况"><a href="#检查集群复制情况" class="headerlink" title="检查集群复制情况"></a>检查集群复制情况</h2></li>
<li>分别连接指定节点<br>zkCli.sh 后加参数-server 表示连接指定IP与端口。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./bin/zkCli.sh -server 127.0.0.1:2181</span><br><span class="line">./bin/zkCli.sh -server 127.0.0.1:2182</span><br><span class="line">./bin/zkCli.sh -server 127.0.0.1:2183</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>在任意一个连接中创建删除数据查看其它节点是否同步成功</em><br><em>-server参数后同时连接多个服务节点，并用逗号隔开127.0.0.1:2181,127.0.0.1:2182</em></p>
<ol start="2">
<li>测试数据同步<br><img src="https://img-blog.csdnimg.cn/20210303175632571.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210303175703138.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210303175751796.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021030317584657.png" alt="在这里插入图片描述"></li>
</ol>
<h2 id="集群角色说明"><a href="#集群角色说明" class="headerlink" title="集群角色说明"></a>集群角色说明</h2><p>zookeeper 集群中总共有三种角色，分别是leader（主节点）follower(子节点) observer（次级子节点）<br>| 角色   | 描述   |<br>|:—-|:—-:|<br>| <strong>leader</strong>   | 主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。   |<br>| <strong>follower</strong>   | 子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。   |<br>| <strong>observer</strong>   | 次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。   | </p>
<p>observer配置只要在集群配置中加上observer后缀即可，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.3&#x3D;&#x3D;127.0.0.1:2889:3889:observer</span><br></pre></td></tr></table></figure>
<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>通过 ./bin/zkServer.sh status &lt;zoo配置文件&gt; 命令可以查看到节点状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo1.cfg</span><br><span class="line">Mode: follower</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo2.cfg</span><br><span class="line">Mode: leader</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh status conf&#x2F;zoo3.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210303180619736.png" alt="在这里插入图片描述"></p>
<p>我们从上面可以发现集群中第二个节点为leader，选举机制如下图:<br><img src="https://img-blog.csdnimg.cn/20210303182419836.png" alt="在这里插入图片描述"><br><strong>选举机制说明</strong></p>
<ol>
<li>第一轮投票全部投给自己</li>
<li>第二轮投票给myid比自己大的相邻节点</li>
<li>如果得票超过半数，选举结束。</li>
</ol>
<p><strong>选举触发</strong></p>
<p>当集群中的服务器出现已下两种情况时会进行Leader的选举</p>
<ol>
<li>服务节点初始化启动</li>
<li>半数以上的节点无法和Leader建立连接</li>
</ol>
<p>当节点初始起动时会在集群中寻找Leader节点，如果找到则与Leader建立连接，其自身状态变化<strong>follower</strong>或<strong>observer</strong>。如果没有找到Leader，当前节点状态将变化LOOKING，进入选举流程。在集群运行其间如果follower或observer节点宕机只要不超过半数并不会影响整个集群服务的正常运行。但如果leader宕机，将暂停对外服务，所有follower将进入LOOKING 状态，进入选举流程。</p>
<h2 id="数据同步机制"><a href="#数据同步机制" class="headerlink" title="数据同步机制"></a>数据同步机制</h2><p>zookeeper 的数据同步是为了保证各节点中数据的一致性,其中有两个流程，一个是正常的客户端数据提交，另一个是集群某个节点宕机在恢复后的数据同步。</p>
<p><strong>客户端写入流程说明</strong></p>
<ol>
<li>client向zk中的server发送写请求，如果该server不是leader，则会将该写请求转发给leader server，leader将请求事务以proposal形式分发给follower；</li>
<li>当follower收到收到leader的proposal时，根据接收的先后顺序处理proposal；</li>
<li>当Leader收到follower针对某个proposal过半的ack后，则发起事务提交，重新发起一个commit的proposal</li>
<li>Follower收到commit的proposal后，记录事务提交，并把数据更新到内存数据库；</li>
<li>当写成功后，反馈给client。</li>
</ol>
<p><strong>服务节点初始化同步</strong></p>
<p>在集群运行过程当中如果有一个follower节点宕机，由于宕机节点没过半，集群仍然能正常服务。当leader 收到新的客户端请求，此时无法同步给宕机的节点。造成数据不一至。为了解决这个问题，当节点启动时，第一件事情就是找当前的Leader，比对数据是否一至。不一至则开始同步,同步完成之后在进行对外提供服务。如何比对Leader的数据版本呢，这里通过<strong>ZXID</strong>事物ID来确认。比Leader就需要同步。</p>
<p><strong>ZXID</strong></p>
<p>ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致,低32位的数字简单加1。高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。 </p>
<h2 id="四字运维命令"><a href="#四字运维命令" class="headerlink" title="四字运维命令"></a>四字运维命令</h2><p>ZooKeeper响应少量命令。每个命令由四个字母组成。可通过telnet或nc向ZooKeeper发出命令。<br>这些命令默认是关闭的，需要配置4lw.commands.whitelist来打开，可打开部分或全部示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开指定命令</span><br><span class="line">4lw.commands.whitelist&#x3D;stat, ruok, conf, isro</span><br><span class="line">#打开全部</span><br><span class="line">4lw.commands.whitelist&#x3D;*</span><br></pre></td></tr></table></figure>

<p>安装Netcat工具，已使用nc命令 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装Netcat 工具</span><br><span class="line">yum install -y nc</span><br><span class="line">#查看服务器及客户端连接状态</span><br><span class="line">echo stat | nc localhost 2181</span><br></pre></td></tr></table></figure>
<p><strong>命令列表</strong></p>
<ol>
<li>conf：3.3.0中的新增功能：打印有关服务配置的详细信息。</li>
<li>缺点：3.3.0中的新增功能：列出了连接到该服务器的所有客户端的完整连接/会话详细信息。包括有关已接收/已发送的数据包数量，会话ID，操作等待时间，最后执行的操作等信息。</li>
<li>crst：3.3.0中的新增功能：重置所有连接的连接/会话统计信息。</li>
<li>dump：列出未完成的会话和临时节点。这仅适用于领导者。</li>
<li>envi：打印有关服务环境的详细信息</li>
<li>ruok：测试服务器是否以非错误状态运行。如果服务器正在运行，它将以imok响应。否则，它将完全不响应。响应“ imok”不一定表示服务器已加入仲裁，只是服务器进程处于活动状态并绑定到指定的客户端端口。使用“ stat”获取有关状态仲裁和客户端连接信息的详细信息。</li>
<li>srst：重置服务器统计信息。</li>
<li>srvr：3.3.0中的新功能：列出服务器的完整详细信息。</li>
<li>stat：列出服务器和连接的客户端的简要详细信息。</li>
<li>wchs：3.3.0中的新增功能：列出有关服务器监视的简要信息。</li>
<li>wchc：3.3.0中的新增功能：按会话列出有关服务器监视的详细信息。这将输出具有相关监视（路径）的会话（连接）列表。请注意，根据手表的数量，此操作可能会很昂贵（即影响服务器性能），请小心使用。</li>
<li>dirs：3.5.1中的新增功能：以字节为单位显示快照和日志文件的总大小</li>
<li>wchp：3.3.0中的新增功能：按路径列出有关服务器监视的详细信息。这将输出具有关联会话的路径（znode）列表。请注意，根据手表的数量，此操作可能会很昂贵（即影响服务器性能），请小心使用。</li>
<li>mntr：3.4.0中的新增功能：输出可用于监视集群运行状况的变量列表。</li>
</ol>
]]></content>
      <categories>
        <category>middleware</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper Java客户端使用</title>
    <url>/middleware/zookeeper/javaclient/</url>
    <content><![CDATA[<h2 id="客户端API常规应用"><a href="#客户端API常规应用" class="headerlink" title="客户端API常规应用"></a>客户端API常规应用</h2><p>zookeeper 提供了java与C两种语言的客户端。本文引用的是java客户端。引入最新的maven依赖：<br> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h3><p>常规的客户端类是 org.apache.zookeeper.ZooKeeper，实例化该类之后将会自动与集群建立连接。</p>
<ol>
<li>构造方法<br><img src="https://img-blog.csdnimg.cn/20210302153927213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>参数说明</li>
</ol>
<p>| 参数名称   | 类型   | 说明   |<br>|:—-|:—-|:—-|:—-:|<br>| connectString   | <strong>String</strong>  | 连接串，包括ip+端口 ,集群模式下用逗号隔开  192.168.0.149:2181,192.168.0.150:2181   |<br>| sessionTimeout   | <strong>int</strong>   | 会话超时时间，该值不能超过服务端所设置的  <em>minSessionTimeout 和maxSessionTimeout</em>   |<br>| watcher   | Watcher    | 会话监听器，服务端事件将会触该监听   |<br>| sessionId   |<strong>long</strong>   | 自定义会话ID   |<br>| sessionPasswd   | <strong>byte</strong>[]   | 会话密码   |<br>| canBeReadOnly   |<strong>boolean</strong>| 该连接是否为只读的   |<br>| hostProvider   | HostProvider    | 服务端地址提供者，指示客户端如何选择某个服务来调用，默认采用StaticHostProvider实现   | </p>
<h3 id="创建、查看节点"><a href="#创建、查看节点" class="headerlink" title="创建、查看节点"></a>创建、查看节点</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>通过org.apache.zookeeper.ZooKeeper#create()即可创建节点</p>
<ol>
<li><p>方法列表<img src="https://img-blog.csdnimg.cn/20210302155514988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>参数说明</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">path</td>
<td align="left">String</td>
<td align="left">节点路径</td>
</tr>
<tr>
<td align="left">data</td>
<td align="left">byte[]</td>
<td align="left">节点值</td>
</tr>
<tr>
<td align="left">acl</td>
<td align="left">List<ACL></ACL></td>
<td align="left">节点权限列表(可设置多组权限)</td>
</tr>
<tr>
<td align="left">createMode</td>
<td align="left">CreateMode</td>
<td align="left">节点类型</td>
</tr>
<tr>
<td align="left">cb</td>
<td align="left">StringCallback</td>
<td align="left">异步创建结果回调</td>
</tr>
<tr>
<td align="left">ctx</td>
<td align="left">Object</td>
<td align="left">异步回调上下文</td>
</tr>
<tr>
<td align="left">#### 查看节点</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">通过org.apache.zookeeper.ZooKeeper#getData()即可查看节点</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1. 方法</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://img-blog.csdnimg.cn/20210302155358985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ol start="2">
<li>参数说明：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">path</td>
<td align="left">String</td>
<td align="left">节点路径</td>
</tr>
<tr>
<td align="left">watch</td>
<td align="left"><strong>boolean</strong></td>
<td align="left">是否添加监听</td>
</tr>
<tr>
<td align="left">watcher</td>
<td align="left">Watcher</td>
<td align="left">监听处理器</td>
</tr>
<tr>
<td align="left">cb</td>
<td align="left">DataCallback</td>
<td align="left">异步调用结果回调</td>
</tr>
<tr>
<td align="left">ctx</td>
<td align="left">Object</td>
<td align="left">异步调用上下文参数</td>
</tr>
</tbody></table>
<h4 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h4><p>通过org.apache.zookeeper.ZooKeeper#getChildren()即可获取子节点。</p>
<ol>
<li>方法<br><img src="https://img-blog.csdnimg.cn/20210302160043319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pldl9qYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>参数说明</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">path</td>
<td align="center">String</td>
<td align="left">节点路径</td>
</tr>
<tr>
<td align="center">watch</td>
<td align="center"><strong>boolean</strong></td>
<td align="left">是否添加监听</td>
</tr>
<tr>
<td align="center">watcher</td>
<td align="center">Watcher</td>
<td align="left">监听处理器</td>
</tr>
<tr>
<td align="center">cb</td>
<td align="center">Children2Callback</td>
<td align="left">异步回调函数</td>
</tr>
<tr>
<td align="center">ctx</td>
<td align="center">Object</td>
<td align="left">回调上下文</td>
</tr>
</tbody></table>
<h3 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h3><p>在getData() 与getChildren()两个方法中可分别设置监听数据变化和子节点变化。通过设置watch为true，当前事件触发时会调用zookeeper()构建函数中Watcher.process()方法。也可以添加watcher参数来实现自定义监听。一般采用后者。</p>
<p><em>注：所有的监听都是一次性的，如果要持续监听需要触发后在添加一次监听。</em></p>
<h3 id="设置节点ACL权限"><a href="#设置节点ACL权限" class="headerlink" title="设置节点ACL权限"></a>设置节点ACL权限</h3><p>ACL包括结构为scheme:id:permission（有关ACL的介绍参照上一篇 <a href="https://blog.csdn.net/Zev_java/article/details/114127609" target="_blank" rel="noopener">zookeeper介绍及基本使用</a>）<br>客户端中由org.apache.zookeeper.data.ACL 类表示，类结构如下：<br><img src="https://img-blog.csdnimg.cn/20210302160721679.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302160749697.png" alt="在这里插入图片描述"><br>权限位的表示方式通过 数字位移 实现。每个权限位都是一个唯一数字，将其合时通过或运行生成一个全新的数字即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Perms</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> WRITE = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> DELETE = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> ADMIN = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ALL = READ | WRITE | CREATE | DELETE | ADMIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三方客户端ZkClient"><a href="#第三方客户端ZkClient" class="headerlink" title="第三方客户端ZkClient"></a>第三方客户端ZkClient</h3><p>zkClient 是在zookeeper客户端基础之上封装的，使用上更加友好。主要变化如下：</p>
<ul>
<li>可以设置持久监听，或删除某个监听</li>
<li>可以插入JAVA对象，自动进行序列化和反序列化</li>
<li>简化了基本的增删改查操作。</li>
</ul>
<p>具体api 此处不一一介绍了，自行查看吧。maven 依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.101tec/zkclient --&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>middleware</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper源码启动</title>
    <url>/middleware/zookeeper/sourcecode/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><blockquote>
<p>// git地址 版本3.5.8<br><a href="https://github.com/apache/zookeeper.git" target="_blank" rel="noopener">https://github.com/apache/zookeeper.git</a></p>
</blockquote>
<h2 id="导入idea"><a href="#导入idea" class="headerlink" title="导入idea"></a>导入idea</h2><p><img src="https://img-blog.csdnimg.cn/20210401175434668.png" alt="在这里插入图片描述"></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1.源码导入后，org.apache.zookeeper.Version类会报错，需要建一个辅助类<br>     <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.zookeeper.version;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MAJOR = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> MINOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> MICRO = <span class="number">0</span>;</span><br><span class="line">    String QUALIFIER = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> REVISION =-<span class="number">1</span>;</span><br><span class="line">    String REVISION_HASH = <span class="string">"1"</span>;</span><br><span class="line">    String BUILD_DATE = <span class="string">"2020‐12‐15"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.根目录执行</p>
<blockquote>
<p>mvn clean install ‐DskipTests</p>
</blockquote>
<p>3.入口类</p>
<p>开源项目找入口类一般都是从启动脚本去找，可以从bin目录下的zkServer.sh或    zkServer.cmd里找到启动主类运行即可.下图可以看到启动类为:</p>
<blockquote>
<p>org.apache.zookeeper.server.quorum.QuorumPeerMain</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210401180040837.png" alt="在这里插入图片描述"><br>4.配置文件</p>
<blockquote>
<p>1.将conf文件夹里的zoo_sample.cfg文件复制一份改名为zoo.cfg<br>2.将zoo.cfg文件位置配置到启动参数里</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210401180340648.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210401180424942.png" alt="在这里插入图片描述"></p>
<p><strong>注意</strong></p>
<ul>
<li>启动之前需要先将zookeeper-server项目里pom.xml文件里依赖的包(除了jline)的scope为provided这一行全部注释掉。</li>
<li>将conf文件夹里的log4j.properties文件复制一份到zookeeper-server项目的 \target\classes 目录下，这样项目启动时才会打印日志<br><img src="https://img-blog.csdnimg.cn/20210401181221236.png" alt="在这里插入图片描述"><h2 id="本地客户端连接ZK"><a href="#本地客户端连接ZK" class="headerlink" title="本地客户端连接ZK"></a>本地客户端连接ZK</h2>配置运行参数:-server localhost:2181,如图:<br><img src="https://img-blog.csdnimg.cn/20210401181342829.png" alt="在这里插入图片描述"><br>启动客户端连接<br><img src="https://img-blog.csdnimg.cn/20210401181443367.png" alt="在这里插入图片描述"><br>操作节点<br><img src="https://img-blog.csdnimg.cn/20210401181517939.png" alt="在这里插入图片描述"><h2 id="zookeeper-源码集群启动"><a href="#zookeeper-源码集群启动" class="headerlink" title="zookeeper 源码集群启动"></a>zookeeper 源码集群启动</h2></li>
</ul>
<p>1.新建目录data，并添加子目录zk1、zk2、zk3<br><img src="https://img-blog.csdnimg.cn/20210401181653375.png" alt="在这里插入图片描述"><br>2.分别在zk1\zk2\zk3添加文件myid并输入对应节点序号<br><img src="https://img-blog.csdnimg.cn/20210401182123209.png" alt="在这里插入图片描述"><br>3.config目录复制3份zoo.cfg 重命名为zoo1.cfg、zoo2.cfg、zoo3.cfg<br><img src="https://img-blog.csdnimg.cn/20210401182531999.png" alt="在这里插入图片描述"><br>4.启动集群<br><img src="https://img-blog.csdnimg.cn/20210401182643145.png" alt="在这里插入图片描述"></p>
<p><strong>到此完事项目启动完事了。</strong></p>
]]></content>
      <categories>
        <category>middleware</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器子系统</title>
    <url>/java/jvm/ClassLoader/</url>
    <content><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>  <em>JVM中有两种类型的类加载器，由C++编写的及由Java编写的。除了启动类加载器（Bootstrap Class Loader）是由C++编写的，其他都是由Java编写的。由Java编写的类加载器都继承自类java.lang.ClassLoader。各种类加载器之间存在逻辑上的父子关系，后面可以通过代码查看。</em><br>    <img src="/java/jvm/ClassLoader/%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB.jpg" alt="类加载器父子关系"></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>  <em>因为启动类加载器是由C++编写的，通过Java程序去查看显示的是null，因此，启动类加载器无法被Java程序调用启动类加载器不像其他类加载器有实体，它是没有实体的，JVM将C++处理类加载的一套逻辑定义为启动类加载器。</em></p>
<pre><code>/**
 * 查看类加载器的默认加载路径  也可以通过-Xbootclasspath 自行指定
 */
 public class ClassLoaderTest2 {

    public static void main(String[] args) {
        URL[] urls = Launcher.getBootstrapClassPath().getURLs();
        for (URL url:urls){
            System.out.println(url);
        }
    }
 }
 结果为固定路径:
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/resources.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/sunrsasign.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/jsse.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/jce.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/charsets.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/jfr.jar
 file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/classes</code></pre><p>   <em>启动类加载器实际上是一段c++代码逻辑 从openjdk源码体现如下:</em></p>
<pre><code>int JNICALL
JavaMain(void * _args)
{
    ……
    mainClass = LoadMainClass(env, mode, what);
    ……
}

static jclass
LoadMainClass(JNIEnv *env, int mode, char *name)
{
    jmethodID mid;
    jstring str;
    jobject result;
    jlong start, end;
    jclass cls = GetLauncherHelperClass(env);
    NULL_CHECK0(cls);
    if (JLI_IsTraceLauncher()) {
        start = CounterGet();
    }
    NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
                &quot;checkAndLoadMain&quot;,
                &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;));

    str = NewPlatformString(env, name);
    CHECK_JNI_RETURN_0(
        result = (*env)-&gt;CallStaticObjectMethod(
            env, cls, mid, USE_STDERR, mode, str));

    if (JLI_IsTraceLauncher()) {
        end   = CounterGet();
        printf(&quot;%ld micro seconds to load main class\n&quot;,
               (long)(jint)Counter2Micros(end-start));
        printf(&quot;----%s----\n&quot;, JLDEBUG_ENV_ENTRY);
    }

    return (jclass)result;
}

jclass
GetLauncherHelperClass(JNIEnv *env)
{
    if (helperClass == NULL) {
        NULL_CHECK0(helperClass = FindBootStrapClass(env,
                &quot;sun/launcher/LauncherHelper&quot;));
    }
    return helperClass;
}

jclass
FindBootStrapClass(JNIEnv *env, const char* classname)
{
   if (findBootClass == NULL) {
       findBootClass = (FindClassFromBootLoader_t *)dlsym(RTLD_DEFAULT,
          &quot;JVM_FindClassFromBootLoader&quot;);
       if (findBootClass == NULL) {
           JLI_ReportErrorMessage(DLL_ERROR4,
               &quot;JVM_FindClassFromBootLoader&quot;);
           return NULL;
       }
   }
   return findBootClass(env, classname);
}

JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
                                              const char* name))
  JVMWrapper2(&quot;JVM_FindClassFromBootLoader %s&quot;, name);

  // Java libraries should ensure that name is never null...
  if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
    // It&apos;s impossible to create this class;  the name cannot fit
    // into the constant pool.
    return NULL;
  }

  TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);
  Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
  if (k == NULL) {
    return NULL;
  }

  if (TraceClassResolution) {
    trace_class_resolution(k);
  }
  return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
JVM_END</code></pre><p>  <em>这套逻辑做的事情就是通过启动类加载器加载类sun.launcher.LauncherHelper，执行该类的方法checkAndLoadMain，加载main函数所在的类，启动扩展类加载器、应用类加载器也是在这个时候完成的</em></p>
<h3 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h3><pre><code>/**
 * 查看拓展类加载路径 也可以通过java.ext.dirs指定
 */
public static void main(String[] args) {
    ClassLoader classLoader = ClassLoader.getSystemClassLoader().getParent();
    URLClassLoader urlClassLoader = (URLClassLoader) classLoader;
    URL[] urls = urlClassLoader.getURLs();
    for (URL url : urls) {
        System.out.println(url);
    }
}
结果:
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/sunec.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/nashorn.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/cldrdata.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/jfxrt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/dnsns.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/localedata.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/jaccess.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext/zipfs.jar
file:/System/Library/Java/Extensions/MRJToolkit.jar</code></pre><h3 id="应用类加载器"><a href="#应用类加载器" class="headerlink" title="应用类加载器"></a>应用类加载器</h3><p>   <em>默认加载用户程序的类加载器</em></p>
<pre><code>/**
 * 查看加载路径  可以通过java.class.path指定    
 */
public static void main(String[] args) {
    String[] urls = System.getProperty(&quot;java.class.path&quot;).split(&quot;:&quot;);
    for (String url : urls) {
        System.out.println(url);
    }
    System.out.println(&quot;================================&quot;);
    URLClassLoader classLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();
    URL[] urls1 = classLoader.getURLs();
    for (URL url : urls1) {
        System.out.println(url);
    }
}
结果为你项目本地包所在路径</code></pre><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>   <em>继承类java.lang.ClassLoader</em></p>
<pre><code>public class ClassLoadeTest1 extends ClassLoader{
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoadeTest1 classLoadeTest1 = new ClassLoadeTest1();
        Class&lt;?&gt; aClass = classLoadeTest1.loadClass(Demo1.class.getName());
        System.out.println(aClass);
        System.out.println(aClass.getClassLoader());
    }
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        System.out.println(&quot;findClass&quot;);
        return null;
    }
}
结果：
   class com.example.classloade.Demo1
   sun.misc.Launcher$AppClassLoader@18b4aac2
 因为类加载中的双亲委派 所以打印出的加载类为AppClassLoader 这也是自定义的默认加载器</code></pre><p>   <em>自定义类加载器也可以打破双亲委派，看源码 此处代码说明类加载器父子关系图</em></p>
<pre><code>/**
 * 类加载过程如下 
 * 自定义加载器只需要重写loadClass 在向上委托判断初改成自己加载逻辑即打破双亲委派
 **/
  protected Class&lt;?&gt; loadClass(String name, boolean resolve)
     throws ClassNotFoundException{

     synchronized (getClassLoadingLock(name)) {
        //判断类是否加载过
         Class&lt;?&gt; c = findLoadedClass(name); 
         //==null 没有加载
         if (c == null) {
             long t0 = System.nanoTime();
             try {
                 //判断是否有父级 
                 if (parent != null) {  
                     //有父级委托父级加载 向上委派
                     c = parent.loadClass(name, false);
                 } else {
                     //没有的话直接使用启动类加载器 最后调用的是navicat方法 进入c++
                     c = findBootstrapClassOrNull(name);
                 }
             } catch (ClassNotFoundException e) {
                 // ClassNotFoundException thrown if class not found
                 // from the non-null parent class loader
             }

             if (c == null) {
                 // If still not found, then invoke findClass in order
                 // to find the class.
                 long t1 = System.nanoTime();
                 c = findClass(name);

                 // this is the defining class loader; record the stats
                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                 sun.misc.PerfCounter.getFindClasses().increment();
             }
         }
         //类是否解析
         if (resolve) {
             //解析类
             resolveClass(c);
         }
         return c;
     }
 }</code></pre><h2 id="类加载器创建链"><a href="#类加载器创建链" class="headerlink" title="类加载器创建链"></a>类加载器创建链</h2><p><em>刚才已经讲了启动类加载器是没有没有实体的，只是将一段c++代码逻辑命名成启动类加载器。启动类加载器做的事情是：<br>    加载类sun.launcher.LauncherHelper<br>    执行该类的方法checkAndLoadMain<br>    启动类、扩展类、应用类加载器逻辑上的父子关系就是在这个方法的调用链中生成</em></p>
<p>1.\openjdk\jdk\src\share\classes\sun\launcher\LauncherHelper.java 核心代码</p>
<pre><code>public enum LauncherHelper {
……
    private static final ClassLoader scloader = ClassLoader.
                                        getSystemClassLoader();
……
    public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr,
                                            int mode,
                                            String what) {
        ……
        mainClass = scloader.loadClass(cn);
        ……</code></pre><p>2.\openjdk\jdk\src\share\classes\java\lang\ClassLoader.java 核心代码sun.misc.Launcher.getLauncher();</p>
<pre><code>public static ClassLoader getSystemClassLoader() {
        initSystemClassLoader();
        if (scl == null) {
            return null;
        }
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkClassLoaderPermission(scl, Reflection.getCallerClass());
        }
        return scl;
    }

    private static synchronized void initSystemClassLoader() {
        if (!sclSet) {
            if (scl != null)
                throw new IllegalStateException(&quot;recursive invocation&quot;);
            sun.misc.Launcher l = sun.misc.Launcher.getLauncher();
        ……</code></pre><p>3.\openjdk\jdk\src\share\classes\sun\misc\Launcher.java </p>
<pre><code>核心代码：
• private static Launcher launcher = new Launcher();
• extcl = ExtClassLoader.getExtClassLoader();
• loader = AppClassLoader.getAppClassLoader(extcl);
• Thread.currentThread().setContextClassLoader(loader);//设置当前线程上下文类加载器

public class Launcher {
    private static URLStreamHandlerFactory factory = new Factory();
    private static Launcher launcher = new Launcher();
    private static String bootClassPath =
        System.getProperty(&quot;sun.boot.class.path&quot;);

    public static Launcher getLauncher() {
        return launcher;
    }

    private ClassLoader loader;

    public Launcher() {
        // Create the extension class loader
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                &quot;Could not create extension class loader&quot;, e);
        }

        // Now create the class loader to use to launch the application
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                &quot;Could not create application class loader&quot;, e);
        }

        // Also set the context class loader for the primordial thread.

        Thread.currentThread().setContextClassLoader(loader);
    ……</code></pre><p>4.扩展类加载器的创建流程</p>
<pre><code> public static ExtClassLoader getExtClassLoader() throws IOException{
     ……
       return new ExtClassLoader(dirs);
     ……

//第二个参数传的是null，其实就是parent=null
public ExtClassLoader(File[] dirs) throws IOException {
          super(getExtURLs(dirs), null, factory);
      }
 URLClassLoader(URL[] urls, ClassLoader parent,
                 AccessControlContext acc) {</code></pre><p>5.应用类加载器的创建流程</p>
<pre><code>public static ClassLoader getAppClassLoader(final ClassLoader extcl)
            throws IOException {
    final String s = System.getProperty(&quot;java.class.path&quot;);
    final File[] path = (s == null) ? new File[0] : getClassPath(s);

    // Note: on bugid 4256530
    // Prior implementations of this doPrivileged() block supplied
    // a rather restrictive ACC via a call to the private method
    // AppClassLoader.getContext().This proved overly restrictive
    // when loading  classes.Specifically it prevent
    // accessClassInPackage.sun.* grants from being honored.
    //
    return AccessController.doPrivileged(
        new PrivilegedAction&lt;AppClassLoader&gt;() {
            public AppClassLoader run() {
                URL[] urls =
                    (s == null) ? new URL[0] : pathToURLs(path);
                return new AppClassLoader(urls, extcl);
            }
        });
}

AppClassLoader(URL[] urls, ClassLoader parent) {
    super(urls, parent, factory);
}</code></pre><p>   <em>应用类、扩展类加载器的父子关系就是这样建立的.</em></p>
<h2 id="类加载器加载完成后的存储"><a href="#类加载器加载完成后的存储" class="headerlink" title="类加载器加载完成后的存储"></a>类加载器加载完成后的存储</h2><p>   <em>类加载完成会存储在方法区 而不同的类加载器加载的类都有其相对应的一块区域。如果不同的加载器加载了同一个class 那么他们是两份数据当然也不是同一个类了</em></p>
<h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p>   <em>如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。</em>  </p>
<p>   <img src="/java/jvm/ClassLoader/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.jpg" alt="双亲委派图解">  </p>
<h2 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h2><p><em>因为在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派。<br>类似这样的情况就需要打破双亲委派。打破双亲委派的意思其实就是不委派、向下委派</em></p>
<ul>
<li>方式</li>
</ul>
<p>1.自定义类加载器<br>    <em>1.4 中代码有提及</em><br>2.SPI<br>    <em>是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。这一机制为很多框架扩展提供了可能，比如在Dubbo、JDBC中都使用到了SPI机制</em></p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>1.是什么<br>   <em>一种特殊的类加载器，可以通过Thread获取，基于此可实现逆向委托加载</em><br>2.存在的理由<br>   <em>为了解决双亲委派的缺陷而生</em><br>3.如何使用</p>
<pre><code>//获取
Thread.currentThread().getContextClassLoader()
//设置
Thread.currentThread().setContextClassLoader(new Classloader_4());   </code></pre><h2 id="沙箱安全"><a href="#沙箱安全" class="headerlink" title="沙箱安全"></a>沙箱安全</h2><p>   <em>看openjdk源码会看到有这样的判断AccessController.doPrivileged.比如我定义了一个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String,但是由于沙箱安全机制，所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion,extsion没有就到aapclassloader，但是由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染.它的主要作用为保护核心类库</em></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机</title>
    <url>/java/jvm/introduce/</url>
    <content><![CDATA[<p>java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。比如kotlin、scala等。</p>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><p>JVM的主要由三部分组成</p>
<ul>
<li>类加载子系统</li>
<li>运行时数据区（内存结构）</li>
<li>执行引擎<br><img src="/java/jvm/introduce/jvm.jpg" alt="jvm结构"></li>
</ul>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/java/jvm/introduce/lifecircle.jpg" alt="生命周期"><br>1.加载<br>    <em>将class文件读取到内存</em><br>2.连接<br>    2.1 验证<br>    <em>验证字节码文件的正确性</em><br>    2.2  准备<br>    <em>给类的静态变量分配内存，并赋予默认值</em><br>    2.3 解析<br>    <em>类装载器装入类所引用的其它所有类</em><br>3.初始化<br>    <em>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块</em><br>4.使用<br>5.卸载</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>启动类加载器(Bootstrap ClassLoader)<br>  <em>负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</em></li>
<li>扩展类加载器(Extension ClassLoader)<br>  <em>负责加载JRE扩展目录ext中jar类包</em></li>
<li>系统类加载器(Application ClassLoader)<br>  <em>负责加载ClassPath路径下的类包</em></li>
<li>用户自定义加载器(User ClassLoader)<br>  <em>负责加载用户自定义路径下的类包</em><br><img src="/java/jvm/introduce/classLoader.jpg" alt></li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>1.全盘负责委托机制<br>    <em>当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入</em><br>2.双亲委派机制<br>    <em>指先委托父类加载器寻找目标类，在找不到的情况下才会到自己的路径中查找并载入目标类</em><br> 双亲委派的优势<br>    + <em>沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</em><br>    + <em>避免类的重复加载：当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次</em></p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>1.方法区（Method Area）<br>    <em>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</em><br>2.堆（Heap）<br>    <em>虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。</em></p>
<pre><code>2.1 新生代
*类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生代分为两部分：伊甸区（Eden space）和幸存者区（Survivor space），所有的类都是在伊甸区被new出来的。幸存区又分为From和To区。当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收（Minor GC），将Eden区中的不再被其它对象应用的对象进行销毁。然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区。*
2.2 老年代
*新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生Major GC（也可以叫Full GC），进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出OOM（OutOfMemoryError）异常*
2.3 元空间
*在JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。*</code></pre><p>3.栈 (Stack)<br>    <em>Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致</em><br>4.本地方法栈 (Native Method Stack)<br>    <em>类似栈，java栈服务于java方法，而本地方法栈服务于native方法。</em><br>5.程序计数器 (Program Counter Register)<br>    <em>就是一个指针，指向下一跳指令的地址，就是即将要执行的指令，由执行引擎进行读取，所占的内存空间很小，几乎可以忽略不计</em></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized锁状态及性能对比</title>
    <url>/java/jvm/synchronized/</url>
    <content><![CDATA[<h2 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>无锁<br> <em>没有synchronized关键字修饰</em></li>
<li>偏向锁<br>  <em>JVM开启偏向锁时只有单个线程调用同步代码（不存在竞争条件）且无法重新偏向（单个锁情况，不考虑批量重偏向^[t1线程实例化同一个类多个对象并加锁，t2线程也对其加锁 由于锁升级会进行多次锁撤销操作，JVM会认为接下来的对象需要批量重偏向而不是进行锁升级为轻量级]</em></li>
<li>轻量级锁<br>  <em>多个线程调用同步代码，但是线程之间交替执行例如调用join().-自旋锁也是产生轻量级锁的一个方式</em></li>
<li>重量级锁<br>  <em>多个线程调用同步代码，且存在锁竞争</em></li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="对象头介绍"><a href="#对象头介绍" class="headerlink" title="对象头介绍"></a>对象头介绍</h4><p>   <em>锁状态的标记就在对象头当中。网上32位操作系统对象头的文档很多，下面使用的是64位操作系统介绍</em></p>
<h5 id="对象头的组成-mark-Word"><a href="#对象头的组成-mark-Word" class="headerlink" title="对象头的组成-mark Word"></a>对象头的组成-mark Word</h5><p><em>这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等，32位操作系统和64位操作系统的位长度是不一样的，具体看图:</em></p>
<pre><code>                             32位操作系统
|------------------------------------------------|-------------------| 
|                  Mark Word (32 bits)           |       State       |
|------------------------------------------------|-------------------|
| identity_hashcode:25|age:4|biased_lock:1|lock:2|       Normal      |
|------------------------------------------------|-------------------|
| thread:23 | epoch:2|age:4|biased_lock:1 |lock:2|       Biased      |
|------------------------------------------------|-------------------|
|           ptr_to_lock_record:30         |lock:2|Lightweight Locked |
|------------------------------------------------|-------------------|
|       ptr_to_heavyweight_monitor:30     |lock:2| Heavyweight Locked|
|------------------------------------------------|-------------------|
|                                         |lock:2|    Marked for GC  |
|------------------------------------------------|-------------------|</code></pre><hr>
<pre><code>                                    64位操作系统   
|-------------------------------------------------------------------|-------------------|
|                  Mark Word (64 bits)                              |       State       |
|-------------------------------------------------------------------|-------------------|
| unused:25|identity_hashcode:31|unused:1|age:4|biased_lock:1|lock:2|       Normal      |
|------------------------------------------------------------|------|-------------------|
| thread:54|     epoch:2        |unused:1|age:4|biased_lock:1|lock:2|       Biased      |
|------------------------------------------------------------|------|-------------------|
|                           ptr_to_lock_record:62            |lock:2|Lightweight Locked |
|----------------------------------------------------------- |------|-------------------|
|                        ptr_to_heavyweight_monitor:62       |lock:2| Heavyweight Locked|
|------------------------------------------------------------|------|-------------------|
|                                                            |lock:2|    Marked for GC  |
|---------------------------------------------------------------------------------------|</code></pre><h4 id="JOL工具"><a href="#JOL工具" class="headerlink" title="JOL工具"></a>JOL工具</h4><p>   JOL全称为Java Object Layout，是分析JVM中对象布局的工具，该工具大量使用了Unsafe、JVMTI来解码布局情况，分析结果是比较精准。使用时直接引入maven依赖即可</p>
<pre><code>&lt;!--java状态分析工具--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
    &lt;version&gt;0.9&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h4 id="偏向锁代码"><a href="#偏向锁代码" class="headerlink" title="偏向锁代码"></a>偏向锁代码</h4><pre><code>- JVM偏向锁延迟： JVM启动有大量的同步操作，偏向锁的锁消除性能很差所以JVM启动时会延迟偏向锁的启用。
- 对象进行hashcode以后 就不存在偏向锁 这和对象头的设计有关
- 偏向锁开启后新建对象 会有一个可偏向状态 但是指向的线程号为空 体现为二机制 0

/**
 * 由于在jvm启动时会延迟开启偏向锁 所以使用Thread.sleep(5000)
 * 设置JVM启动参数 -XX:BiasedLockingStartupDelay=0 延迟偏向锁时间0
 */
public class Demo1 {
    public static void main(String[] args) throws InterruptedException {
        //睡眠5秒 使得偏向锁开启 也可以设置启动参数 
        //-XX:BiasedLockingStartupDelay=0 延迟偏向锁时间0
        Thread.sleep(5000);
        A a = new A();
        System.out.println(&quot;锁之前&quot;);
        System.out.println(ClassLayout.parseInstance(a).toPrintable());

        Thread thread = new Thread(){
            @Override
            public void run() {
                synchronized (a){
                    System.out.println(&quot;锁状态&quot;);
                    System.out.println(ClassLayout.parseInstance(a).toPrintable());
                }
            }
        };
        thread.start();
        System.out.println(&quot;锁之后&quot;);
        System.out.println(ClassLayout.parseInstance(a).toPrintable());
    }
}



结果
锁之前
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           a0 c1 00 f8 (10100000 11000001 00000000 11111000) (-134168160)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

锁之后
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 d0 11 1b (00000101 11010000 00010001 00011011) (454152197)
      4     4        (object header)                           e6 7f 00 00 (11100110 01111111 00000000 00000000) (32742)
      8     4        (object header)                           a0 c1 00 f8 (10100000 11000001 00000000 11111000) (-134168160)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 d0 11 1b (00000101 11010000 00010001 00011011) (454152197)
      4     4        (object header)                           e6 7f 00 00 (11100110 01111111 00000000 00000000) (32742)
      8     4        (object header)                           a0 c1 00 f8 (10100000 11000001 00000000 11111000) (-134168160)
结果分别为 101+0 偏向锁状态 101+pid 偏向锁 101+pid偏向锁，后面两次打印结果中可以看到锁指向线程id是相同。 </code></pre><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><pre><code>public class Demo2 {

    //JVM启动设置关闭偏向锁延迟
    public static void main(String[] args) throws InterruptedException {

        A a = new A();
        System.out.println(&quot;锁之前&quot;);
        System.out.println(ClassLayout.parseInstance(a).toPrintable());

        Thread thread = new Thread(){
            @Override
            public void run() {
                synchronized (a){
                    System.out.println(&quot;线程锁状态&quot;);
                    System.out.println(ClassLayout.parseInstance(a).toPrintable());
                }
            }
        };

        /**
         * 主线程先拿锁 执行完成启动第二个线程 否则会产出重量级锁
         */
        synchronized (a){
            System.out.println(&quot;主线程锁状态&quot;);
            System.out.println(ClassLayout.parseInstance(a).toPrintable());
        }

        thread.start();

        System.out.println(&quot;锁之后&quot;);
        System.out.println(ClassLayout.parseInstance(a).toPrintable());
    }
}

结果
锁之前
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

主线程锁状态
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 18 00 7a (00000101 00011000 00000000 01111010) (2046826501)
      4     4        (object header)                           8d 7f 00 00 (10001101 01111111 00000000 00000000) (32653)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

锁之后
线程锁状态
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           f8 c8 12 0f (11111000 11001000 00010010 00001111) (252889336)
      4     4        (object header)                           00 70 00 00 (00000000 01110000 00000000 00000000) (28672)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           f8 c8 12 0f (11111000 11001000 00010010 00001111) (252889336)
      4     4        (object header)                           00 70 00 00 (00000000 01110000 00000000 00000000) (28672)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
结果分别为 101+0 偏向锁状态 101+pid 偏向锁 000 轻量级锁 000 轻量级锁</code></pre><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><pre><code>/**
 * 代码与轻量级锁的代码区别为thread.start()方法调用放到主线程加锁之前 使多个线程之间存在锁竞争
 *（自选状态之外）升级重量级锁
 */
 public class Demo3 {

     //JVM启动设置关闭偏向锁延迟
     public static void main(String[] args) throws InterruptedException {

         A a = new A();
         System.out.println(&quot;锁之前&quot;);
         System.out.println(ClassLayout.parseInstance(a).toPrintable());

         Thread thread = new Thread(){
             @Override
             public void run() {
                 synchronized (a){
                     System.out.println(&quot;线程锁状态&quot;);
                     System.out.println(ClassLayout.parseInstance(a).toPrintable());
                 }
             }
         };

         thread.start();
         /**
          * 主线程先拿锁 执行完成启动第二个线程 否则会产出重量级锁
          */
         synchronized (a){
             System.out.println(&quot;主线程锁状态&quot;);
             System.out.println(ClassLayout.parseInstance(a).toPrintable());
         }



         System.out.println(&quot;锁之后&quot;);
         System.out.println(ClassLayout.parseInstance(a).toPrintable());
     }
 }
结果：
锁之前
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

主线程锁状态
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           5a 57 00 50 (01011010 01010111 00000000 01010000) (1342199642)
      4     4        (object header)                           a8 7f 00 00 (10101000 01111111 00000000 00000000) (32680)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

锁之后
线程锁状态
com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           5a 57 00 50 (01011010 01010111 00000000 01010000) (1342199642)
      4     4        (object header)                           a8 7f 00 00 (10101000 01111111 00000000 00000000) (32680)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

com.example.concurrent.sync.A object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           5a 57 00 50 (01011010 01010111 00000000 01010000) (1342199642)
      4     4        (object header)                           a8 7f 00 00 (10101000 01111111 00000000 00000000) (32680)
      8     4        (object header)                           05 c4 00 f8 (00000101 11000100 00000000 11111000) (-134167547)
     12     4        (loss due to the next object alignment)

 结果分别为001 无锁 010 重量级锁 010重量级锁 010 重量级锁 （锁只会进行升级和锁释放，不会降级）</code></pre><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><pre><code>//JVM启动设置关闭偏向锁延迟 -XX:BiasedLockingStartupDelay=0
public class Demo4 {
    public Long max = 1000000000L;

    public static void main(String[] args) throws InterruptedException {
        Demo4 demo4 = new Demo4();
        long start = System.currentTimeMillis();
        while (demo4.max&gt;0){
            demo4.run1();
        }
        long end = System.currentTimeMillis();
        System.out.println(String.format(&quot;%sms&quot;, end -start));
    }
    public synchronized void run1(){

       max--;
    }
}
执行结果 4294ms</code></pre><h3 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><pre><code>代码同上 将偏向锁延迟开启即可
结果  19682ms</code></pre><h3 id="重量级锁-1"><a href="#重量级锁-1" class="headerlink" title="重量级锁"></a>重量级锁</h3><pre><code> public class Demo5 {
     public CountDownLatch countDownLatch = new CountDownLatch(1000000000);
     public static void main(String[] args) throws InterruptedException {
         Demo5 demo4 = new Demo5();
         long start = System.currentTimeMillis();
         for (int i=0;i&lt;2;i++){
             Thread thread = new Thread(){
                 @Override
                 public void run() {
                     while (demo4.countDownLatch.getCount()&gt;0){
                         demo4.run1();
                     }
                 };
             };
             thread.start();
         }
         demo4.countDownLatch.await();
         long end = System.currentTimeMillis();
         System.out.println(String.format(&quot;%sms&quot;, end -start));
     }
     public synchronized void run1(){

         countDownLatch.countDown();
     }
 }
结果:44597ms</code></pre><p><em>对象头的介绍在下次具体介绍推荐直接到oracle官网查看介绍</em></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
