<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="JAVA,">
  <meta name="keyword" content="java, 编程">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      java对象概述及创建过程 | 张治峰的博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  

  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 4.2.1"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>张治峰的博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/java/" class="item-link">JAVA</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/framework/" class="item-link">开发框架</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/database/" class="item-link">数据库</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/middleware/" class="item-link">中间件</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/essay/" class="item-link">随笔</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/java/" class="menu-link">JAVA</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/framework/" class="menu-link">开发框架</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/database/" class="menu-link">数据库</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/middleware/" class="menu-link">中间件</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/essay/" class="menu-link">随笔</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>java对象概述及创建过程</h2>
  <p class="post-date">2021-01-07</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h1><p><strong>java 对象主要分为三部分:对象头、实例数据、对齐填充。对象头又分为 mark word 和 Kclass word、数组长度（数组对象才有这块区域）,具体描述如下图:</strong><br><img src="/java/jvm/create_obj/struct.jpg" alt></p>
<h1 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h1><p><strong>java对象在创建时主要有下面几个过程: 类加载检查-&gt;申请内存-&gt;初始化-&gt;设置对象头-&gt;执行<init>方法（构造方法）。如下图:</init></strong><br><img src="/java/jvm/create_obj/create.jpg" alt></p>
<h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p><strong>当虚拟机遇到创建对象指令时，会先去常量池中查询是否有 有类的符号引用，并判断类有没有加载完成，没有没有 必须先进行 <a href="/java/jvm/introduce/">类加载过程</a>。</strong></p>
<blockquote>
<p>比如下面代码在创建 A类对象 时 需要先完成A类的加载工作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method()&#123;</span><br><span class="line">    A &#x3D; new A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>在类加载检查完成之后,JVM虚拟机就要为新建的对象分配内存了。对象所需要的内存大小在类加载完成的时候就能完全确定。为对象分配空间 就是 从堆里面划分一块 固定 大小的内存出来。</p>
<blockquote>
<p>JVM又是如何分配内存的? 在多个线程同时申请内存的时候又如何保证不分配到同一个内存地址？</p>
</blockquote>
<h3 id="内存划分方式"><a href="#内存划分方式" class="headerlink" title="内存划分方式"></a>内存划分方式</h3><ol>
<li><p>指针碰撞(Bump the Pointer):</p>
<p> 指针碰撞需要内存是规整的,所有使用过的内存在一侧,没有使用过的内存在另一侧。在中间放着一个指针作为 三八线 分隔,需要分配内存时，只需要将指针向未使用过的那端移动 对象大小 的距离即可。<br> <img src="/java/jvm/create_obj/bump_the_pointer.jpg" alt></p>
</li>
<li><p>空闲列表（Free List）</p>
<p> 如果内存空间不规整的话，使用过的内存和未使用的内存相互交措就不能使用指针碰撞了。虚拟机就需要维护一个列表记录哪些内存是可用的，在分配时找到一块足够大的空间分配给记录并更新列表中的值。<br><img src="/java/jvm/create_obj/free_list.jpg" alt></p>
</li>
</ol>
<h3 id="并发问题解决方式"><a href="#并发问题解决方式" class="headerlink" title="并发问题解决方式"></a>并发问题解决方式</h3><p>在多个线程同时申请内存的时候保证不分配到同一个内存地址有如下两种方式。</p>
<ul>
<li><p>CAS</p>
<p>  内存分配的时候采用CAS加重试方式进行内存分配。</p>
</li>
<li><p>本地线程分配缓冲(TLAB)</p>
<p>  堆在线程创建的时候先划分一块区域给到线程使用,创建对象的时候优先使用自己线程内部的空间,不够的话在使用CAS在共享内存中分配.</p>
</li>
</ul>
<blockquote>
<p>通过­XX:+UseTLAB\­XX:­UseTLAB参数来设定虚拟机是否使用TLAB(JVM默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小。</p>
</blockquote>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>给分配到的内存空间设置零值,比如其中 int 设置为 0,boolean 设置为 false,引用类型为 null，这样可以保证字段属性不被赋值也能被访问（访问的是零值）。</strong></p>
<blockquote>
<p>如果使用的是TLAB方式分配内存,则该步骤在分配时可以直接完成。</p>
</blockquote>
<h2 id="对象头设置"><a href="#对象头设置" class="headerlink" title="对象头设置"></a>对象头设置</h2><p><strong>对象头主要包含两部分：Mark Word（标记字）和Class Pointer（类型指针,指向所属类的元信息），如果是数组对象还得再加一项Array Length（数组长度）</strong><br><strong>设置零值以后,JVM需要给对象的一些必要属性就行设置。比如 对象所属类信息、 锁状态、分代年龄、Hash码等等，这些都在对象头当中。</strong></p>
<blockquote>
<p>对象在不同的状态 以及 32位和64位下都有所不同  其字段以及占用字节数如下:</p>
</blockquote>
<pre><code>                             32位操作系统
|------------------------------------------------|-------------------| 
|                  Mark Word (32 bits)           |       State       |
|------------------------------------------------|-------------------|
| identity_hashcode:25|age:4|biased_lock:1|lock:2|       Normal      |
|------------------------------------------------|-------------------|
| thread:23 | epoch:2|age:4|biased_lock:1 |lock:2|       Biased      |
|------------------------------------------------|-------------------|
|           ptr_to_lock_record:30         |lock:2|Lightweight Locked |
|------------------------------------------------|-------------------|
|       ptr_to_heavyweight_monitor:30     |lock:2| Heavyweight Locked|
|------------------------------------------------|-------------------|
|                                         |lock:2|    Marked for GC  |
|------------------------------------------------|-------------------|</code></pre><hr>
<pre><code>                                    64位操作系统   
|-------------------------------------------------------------------|-------------------|
|                  Mark Word (64 bits)                              |       State       |
|-------------------------------------------------------------------|-------------------|
| unused:25|identity_hashcode:31|unused:1|age:4|biased_lock:1|lock:2|       Normal      |
|------------------------------------------------------------|------|-------------------|
| thread:54|     epoch:2        |unused:1|age:4|biased_lock:1|lock:2|       Biased      |
|------------------------------------------------------------|------|-------------------|
|                           ptr_to_lock_record:62            |lock:2|Lightweight Locked |
|----------------------------------------------------------- |------|-------------------|
|                        ptr_to_heavyweight_monitor:62       |lock:2| Heavyweight Locked|
|------------------------------------------------------------|------|-------------------|
|                                                            |lock:2|    Marked for GC  |
|---------------------------------------------------------------------------------------|</code></pre><h2 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h2><p><strong>执行<init>方法，就是对象按照编码人员的需求进行初始化。包括父类的构造方法以及自己的构造方法。</init></strong></p>
<h1 id="内存大小计算（JOL）"><a href="#内存大小计算（JOL）" class="headerlink" title="内存大小计算（JOL）"></a>内存大小计算（JOL）</h1><p><strong>对象的大小我们可以通过 JOL 工具进行打印分析,这里我们需要引入工具依赖包如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jol‐core&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>我们来分析一下 Object 对象 int数组 以及 String 的对象大小</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 对象内存大小计算（JOL）</span><br><span class="line"> * @author zhangzhifeng</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ClassLayoutTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(ClassLayout.parseInstance(new Object()).toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(new int[4]).toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(new String()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes </span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line">&#x2F;&#x2F; Object 对象头 markword 占 8 字节 class point 占 4 字节 ,对齐填充 4 字节 总共 16 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">「I object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           6d 01 00 f8 (01101101 00000001 00000000 11111000) (-134217363)</span><br><span class="line">     12     4        (object header)                           04 00 00 00 (00000100 00000000 00000000 00000000) (4)</span><br><span class="line">     16    16    int [I.&lt;elements&gt;                             N&#x2F;A</span><br><span class="line">Instance size: 32 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external &#x3D; 0 bytes total</span><br><span class="line">&#x2F;&#x2F; Object 对象头 中 markword 占 8 字节 class point 占 4 字节 | 实例数据4 个 int 占  字节 总 16 字节 共 32 字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java.lang.String object internals:</span><br><span class="line"> OFFSET  SIZE     TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4          (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4          (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4          (object header)                           da 02 00 f8 (11011010 00000010 00000000 11111000) (-134216998)</span><br><span class="line">     12     4   char[] String.value                              []</span><br><span class="line">     16     4      int String.hash                               0</span><br><span class="line">     20     4          (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line">&#x2F;&#x2F; String 对象头 中 markword 占 8 字节 class-point 占 4 字节 | 实例数据 中 char[] 数组指针 占 4 字节，int hash 字段 占 4字节 |对齐填充 4 字节 总共 24 字节</span><br></pre></td></tr></table></figure>

<h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><p><img src="/java/jvm/create_obj/memory.jpg" alt></p>
<h2 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2><p><strong>通常我们创建的对象都是放在堆中的，在对象不再使用时通过GC进行内存回收，当对象多的时候，会给GC带来较多的压力，所以为了减少临时对象在堆中分配的数量，JVM 通过逃逸分析 将对象进行栈上分配，这样在栈帧出栈的时候对象就会销毁,从而减少GC的压力</strong></p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p><strong>分析对象的作用域是否在当前栈帧（是否只存在创建它的栈帧中）。只能在server模式下才能启用。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; method1 中 user 被返回了 作用域不确定 不能进行栈上分配</span><br><span class="line">public User method1()&#123;</span><br><span class="line">    User user&#x3D; new User();</span><br><span class="line">    user.setName(&quot;zhangsan&quot;);</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; method2 中 user 只在当前方法中生效 作用域确定 可以对user进行栈上分配,栈帧结束直接进行回收。</span><br><span class="line">public void method2()&#123;</span><br><span class="line">    User user&#x3D; new User();</span><br><span class="line">    user.setName(&quot;zhangsan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于上面method2 这种情况 JVM 通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过标量替换优 先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p>
</blockquote>
<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>如果通过逃逸分析确定对象不会被外界访问(如上method2),那么jvm会将对象的属性 分解成 多个 被方法使用的成员变量，这些成员变量在栈帧或者寄存器中。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认 开启。</strong></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>通过 逃逸分析、标量替换的开启和关闭查看堆上的内存分配和GC情况分析栈上分配。</p>
<blockquote>
<p>Object 对象占用16字节 总对象大小为80M,堆内存大小设置为256m,开启GC日志打印 -XX:+PrintGCDetails</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EscapeAnalysisTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int length &#x3D; 5*1024*1024;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">          Object obj &#x3D;   new Object();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.启动参数开启逃逸分析,开启标量替换: -Xmx256m -Xms256m -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+PrintGCDetails，结果如下:<br><img src="/java/jvm/create_obj/escapeAnalysis-1.jpg" alt></p>
<blockquote>
<p>结果分析:没有发生GC 年轻代占用内存 大概7M。(这里JVM启动会加载一些对象)</p>
</blockquote>
<p>2.启动参数关闭逃逸分析,开启标量替换: -Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -XX:+PrintGCDetails，结果如下:<br><img src="/java/jvm/create_obj/escapeAnalysis-2.jpg" alt></p>
<blockquote>
<p>结果分析:发生了一次 年轻代GC 释放空间大概65M,同时年轻代还存在21.8M对象，堆内存对象大小总和为86.8M**</p>
</blockquote>
<p>3.启动参数开启逃逸分析,关闭标量替换: -Xmx256m -Xms256m -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+PrintGCDetails，结果如下:<br><img src="/java/jvm/create_obj/escapeAnalysis-3.jpg" alt></p>
<blockquote>
<p>结果分析:和结果2 相当</p>
</blockquote>
<p><strong>通过结果可以分析如下结论:</strong></p>
<ul>
<li>创建对象不一定会在堆当中。 </li>
<li>需要同时开启逃逸分析 和标量替换才会进行栈上分配 </li>
<li>栈上分配可以减少垃圾回收次数</li>
</ul>
<h2 id="堆分配内存"><a href="#堆分配内存" class="headerlink" title="堆分配内存"></a>堆分配内存</h2><p>JVM 垃圾回收大部分采用分代算法,所以一般会将堆分为年轻代和老年代,默认比例1:2。年轻代采用标记-复制算法进行内存回收,所以又分为 eden区 和两个 survivor 区,如下图所示:<br><img src="/java/jvm/create_obj/heap.jpg" alt></p>
<p>一般新建的对象内存空间都由新生代 eden 区 进行分配,在eden 区空间不够的时候 会进行 Minor GC。第一次 Minor GC 后将剩下的对象会放入其中一块空的survivor中，接下来每一次<br>Minor GC 会将剩余存活对象（包含eden区和上一次放对象的survivor区） 移动到 空的survivor区 然后清空eden 和上一次的存放对象的survivor。年轻代的对象一般存活时间都很短，在一次 Minor GC 后大部分的对象都会被回收所以8:1:1的比例很合适<br>eden区 尽量大，survivor区 够用即可。</p>
<blockquote>
<p>JVM使用个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想比例变化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
</blockquote>
<p>接下来我们用几个例子看一下新建的对象 在堆中内存分布的几种情况。</p>
<blockquote>
<p>测试参数 堆大小256M 年轻代 约 85.3M 老年代约170.6M</p>
</blockquote>
<p>1.eden容量足够时分析, 启动参数: -Xmx256m -Xms256m -XX:+PrintGCDetails</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * new对象 堆内存分配测试</span><br><span class="line"> * @author zhangzhifeng</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HeapAllocationTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int space &#x3D; 1024*1024;</span><br><span class="line">        byte[] allocation&#x3D; new byte[60*space];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/java/jvm/create_obj/heap_test_1.jpg" alt></p>
<blockquote>
<p>根据结果可以知道 当对象所需内存 小于 eden区 大小时 eden 进行内存分配。</p>
</blockquote>
<p>2.新建对象 eden容量 不足时分析, 启动参数: -Xmx256m -Xms256m -XX:+PrintGCDetails</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * new对象 堆内存分配测试</span><br><span class="line"> * @author zhangzhifeng</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HeapAllocationTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int space &#x3D; 1024*1024;</span><br><span class="line">        byte[] allocation&#x3D; new byte[60*space];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; allocation1创建时 eden内存不够会进行垃圾回收 ，allocation 在垃圾回收后 survivor 区放不下 会进入老年代</span><br><span class="line">        byte[] allocation1&#x3D; new byte[10*space];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/java/jvm/create_obj/heap_test_2.jpg" alt></p>
<blockquote>
<p>当创建对象 Eden 空间不足时会进行年轻代的垃圾回收, 垃圾回收后如果在survivor 区放不下 会进入老年代，新建的对象继续放入eden区中。</p>
</blockquote>
<blockquote>
<p>上面两个案例是正常的 内存 分配 方式 ,对于 堆内存分配 JVM还有 一些自己的优化方式。</p>
</blockquote>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象(比如:字符串、数组)。JVM参数 <strong>-XX:PretenureSizeThreshold</strong> 可以设置大 对象的大小(默认值为0 表示任何对象都在新生代中分配，单位是字节)，如果对象超过设置大小会直接进入老年代，不会进入年轻代,这个参数只在 <strong>Serial</strong> 和<strong>ParNew</strong>两个收集器下 有效。</p>
<p>源码查看<br><img src="/java/jvm/create_obj/bigObj.jpg" alt></p>
<blockquote>
<p>示例: 启动参数 -Xmx256m -Xms256m -XX:PretenureSizeThreshold=1000000  -XX:+UseSerialGC -XX:+PrintGCDetails</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * new对象 堆内存分配测试</span><br><span class="line"> * @author zhangzhifeng</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HeapAllocationTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int space &#x3D; 1024*1024;</span><br><span class="line">        byte[] allocation&#x3D; new byte[1*space];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/java/jvm/create_obj/heap_test_3.jpg" alt></p>
<blockquote>
<p>为什么要把大对象直接放入老年代呢?</p>
</blockquote>
<p>为了避免大对象在 minor GC 时的内存复制操作降低效率,也避免造成更多的minor GC。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>如果对象产生在Eden 区 都会有一个分代年龄（标记在对象头 占一个字节 最大15岁）,当它经历过一次minor gc 且 能够被复制进 survivor 区时 那么它的分代年龄就会被 +1 ,对象的分代年龄达到一定的阈值（默认15岁，CMS 默认6 岁 不同的垃圾回收器会有所不同）就会被移入到老年代。<br>阈值 可以通过 <strong>-XX:MaxTenuringThreshold</strong> 设置。</p>
<h3 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h3><p>当前放对象的Survivor区域里,存在各个年龄对象内存和 年龄1+年龄2+…+年龄n &gt; Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么survivor 中 年龄  大于等于 n  的对象 就会直接进入老年代了。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年 龄判断机制一般是在minor gc之后触发的。</p>
<p>c++源码分析(长期存活的对象将进入老年代/动态年龄判断)<br><img src="/java/jvm/create_obj/dynamic_age.jpg" alt></p>
<h2 id="空间担保机制"><a href="#空间担保机制" class="headerlink" title="空间担保机制"></a>空间担保机制</h2><p>年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间,如果可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象) 就会判断一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了 如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。 如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾， 如果回收完还是没有足够空间存放新的对象就会发生”OOM”<br>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#java" >
    <span class="tag-code">java</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/java/jvm/jvm_memory/">
        <span class="nav-arrow">← </span>
        
          JVM内存模型
        
      </a>
    
    
      <a class="nav-right" href="/middleware/zookeeper/index/">
        
          zookeeper介绍及基本使用
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">目录</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#对象结构"><span class="toc-nav-text">对象结构</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#创建过程"><span class="toc-nav-text">创建过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#类加载检查"><span class="toc-nav-text">类加载检查</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#内存分配"><span class="toc-nav-text">内存分配</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#内存划分方式"><span class="toc-nav-text">内存划分方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#并发问题解决方式"><span class="toc-nav-text">并发问题解决方式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#初始化"><span class="toc-nav-text">初始化</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#对象头设置"><span class="toc-nav-text">对象头设置</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#执行-init-方法"><span class="toc-nav-text">执行 init 方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#内存大小计算（JOL）"><span class="toc-nav-text">内存大小计算（JOL）</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#内存分配流程"><span class="toc-nav-text">内存分配流程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#栈上分配"><span class="toc-nav-text">栈上分配</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#逃逸分析"><span class="toc-nav-text">逃逸分析</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#标量替换"><span class="toc-nav-text">标量替换</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#测试"><span class="toc-nav-text">测试</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#堆分配内存"><span class="toc-nav-text">堆分配内存</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#大对象直接进入老年代"><span class="toc-nav-text">大对象直接进入老年代</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#长期存活的对象将进入老年代"><span class="toc-nav-text">长期存活的对象将进入老年代</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态年龄判断"><span class="toc-nav-text">动态年龄判断</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#空间担保机制"><span class="toc-nav-text">空间担保机制</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
  (function () {

    var url = 'http://zev_gitee.gitee.io/java/jvm/create_obj/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>





  <script>
    let gitalk = new Gitalk({
      clientID: '7c19a6dde1744eaa8c8e',
      clientSecret: '689f2f34a11a1edad102d8b1c63c57e3ebb87512',
      repo: 'blog-comment',
      owner: 'zhangzhif',
      admin: 'zhangzhif',
      id: 'java对象概述及创建过程',
      distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render(document.getElementById('comments'));
  </script>








    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
<!--  <p class="copyright">-->
<!--    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>-->
<!--    <br>-->
<!--    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>-->
<!--  </p>-->
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>